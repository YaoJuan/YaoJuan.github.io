<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RSA原理</title>
    <url>/2020/04/24/RSA%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p><em>1976年之前用的用的都是对称加密</em></p>
<blockquote>
<p>（1）甲方选择某一种加密规则，对信息进行加密；</p>
<p>（2）乙方使用同一种规则，对信息进行解密。</p>
</blockquote>
<p><em>1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为<a href="http://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange" target="_blank" rel="noopener">“Diffie-Hellman密钥交换算法”</a>。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥</em></p>
<p><em>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</em></p>
<blockquote>
<p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</p>
<p>（2）甲方获取乙方的公钥，然后用它对信息加密。</p>
<p>（3）乙方得到加密后的信息，用私钥解密。</p>
</blockquote>
<p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做<a href="http://zh.wikipedia.org/zh-cn/RSA加密算法" target="_blank" rel="noopener">RSA算法</a>。从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。</p>
<p>这种算法非常<a href="http://en.wikipedia.org/wiki/RSA_Factoring_Challenge" target="_blank" rel="noopener">可靠</a>，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。(归根结底是因为破解RSA需要求)</p>
<p>下面，我就进入正题，解释RSA算法的原理。文章共分成两部分，今天是第一部分，介绍要用到的四个数学概念。你可以看到，RSA算法并不难，只需要一点<a href="http://jeremykun.com/2011/07/30/number-theory-a-primer/" target="_blank" rel="noopener">数论知识</a>就可以理解。</p>
<h3 id="互质关系"><a href="#互质关系" class="headerlink" title="互质关系"></a>互质关系</h3><p><em>质数</em>是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p>
<p>*如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是<a href="http://zh.wikipedia.org/zh-cn/互素" target="_blank" rel="noopener">互质关系</a>（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p>
<p>关于互质关系，不难得到以下结论：</p>
<blockquote>
<ol>
<li><p>任意两个质数构成互质关系，比如13和61。</p>
</li>
<li><p>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。</p>
</li>
<li><p>如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。</p>
</li>
<li><p>1和任意一个自然数是都是互质关系，比如1和99。</p>
</li>
<li><p>p是大于1的整数，则p和p-1构成互质关系，比如57和56。</p>
</li>
<li><p>p是大于1的奇数，则p和p-2构成互质关系，比如17和15。</p>
</li>
</ol>
</blockquote>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><blockquote>
<p>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）</p>
</blockquote>
<p>计算这个值的方法就叫<em>欧拉函数<em>，以<u></u></em>φ(n)</em>表示，在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。</p>
<p>第一种情况</p>
<p>如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。</p>
<p>第二种情况</p>
<p>如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</p>
<p>第三种情况</p>
<p>如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c0573f4a25a.png" alt="2015-08-04/55c0573f4a25a"></p>
<p>比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。</p>
<p>这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。</p>
<p>上面的式子还可以写成下面的形式：</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c0578076585.png" alt="2015-08-04/55c0578076585"></p>
<p>可以看出，上面的第二种情况是 k=1 时的特例。</p>
<p>第四种情况</p>
<p>如果n可以分解成两个互质的整数之积，</p>
<blockquote>
<p>n = p1 × p2</p>
</blockquote>
<p>则</p>
<blockquote>
<p>φ(n) = φ(p1p2) = φ(p1)φ(p2)</p>
</blockquote>
<p>即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。</p>
<p>这一条的证明要用到<a href="http://en.wikipedia.org/wiki/Chinese_remainder_theorem" target="_blank" rel="noopener">“中国剩余定理”</a>，这里就不展开了，只简单说一下思路：如果a与p1互质(a&lt;p1)，b与p2互质(b&lt;p2)，c与p1p2互质(c&lt;p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。</p>
<p>第五种情况</p>
<p>因为任意一个大于1的正整数，都可以写成一系列质数的积。<br><img src="https://box.kancloud.cn/2015-08-04_55c057f99f735.png" alt="2015-08-04/55c057f99f735"></p>
<p>根据第4条的结论，得到<br><img src="https://box.kancloud.cn/2015-08-04_55c05835ca6e2.png" alt="2015-08-04/55c05835ca6e2"></p>
<p>再根据第3条的结论，得到</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c05871f2594.png" alt="2015-08-04/55c05871f2594"></p>
<p>也就等于</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c058b16129e.png" alt="2015-08-04/55c058b16129e"></p>
<p>这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c059446c936.png" alt="2015-08-04/55c059446c936"></p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>欧拉函数的用处，在于[欧拉定理]。”欧拉定理”指的是：</p>
<blockquote>
<p>如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c059520a3e8.png" alt="2015-08-04/55c059520a3e8"></p>
</blockquote>
<p>也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。</p>
<p>欧拉定理的证明比较复杂，这里就省略了。我们只要记住它的结论就行了。</p>
<p>欧拉定理可以大大简化某些运算。比如，7和10互质，根据欧拉定理，</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c05962e83e9.png" alt="2015-08-04/55c05962e83e9"></p>
<p>已知 φ(10) 等于4，所以马上得到7的4倍数次方的个位数肯定是1。</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c0596cb6dd4.png" alt="2015-08-04/55c0596cb6dd4"></p>
<p>因此，7的任意次方的个位数（例如7的222次方），心算就可以算出来。</p>
<p>欧拉定理有一个特殊情况。</p>
<blockquote>
<p>假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c0597866ff0.png" alt="2015-08-04/55c0597866ff0"></p>
</blockquote>
<p>这就是著名的<a href="http://zh.wikipedia.org/wiki/费马小定理" target="_blank" rel="noopener">费马小定理</a>。它是欧拉定理的特例。</p>
<p>欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。</p>
<h3 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h3><blockquote>
<p>如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c059871365d.png" alt="2015-08-04/55c059871365d"></p>
<p>这时，b就叫做a的<a href="http://zh.wikipedia.org/wiki/模反元素" target="_blank" rel="noopener">“模反元素”</a>。</p>
</blockquote>
<p>比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。</p>
<p>欧拉定理可以用来证明模反元素必然存在。</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c059984b9aa.png" alt="2015-08-04/55c059984b9aa"></p>
<p>可以看到，a的 φ(n)-1 次方，就是a的模反元素。</p>
<h3 id="密钥生成的步骤"><a href="#密钥生成的步骤" class="headerlink" title="密钥生成的步骤"></a>密钥生成的步骤</h3><p>前面我介绍了一些数论知识。<br>有了这些知识，我们就可以看懂RSA算法。这是目前地球上最重要的加密算法。</p>
<p>我们通过一个例子，来理解RSA算法。假设<a href="http://zh.wikipedia.org/wiki/爱丽丝与鲍伯" target="_blank" rel="noopener">爱丽丝</a>要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c05a8911a90.png" alt="img"></p>
<p>第一步，随机选择两个不相等的质数p和q。</p>
<p>爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）</p>
<p>第二步，计算p和q的乘积n。</p>
<p>爱丽丝就把61和53相乘。</p>
<blockquote>
<p>n = 61×53 = 3233</p>
</blockquote>
<p>n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p>
<p>第三步，计算n的欧拉函数φ(n)。</p>
<p>根据公式：</p>
<blockquote>
<p>φ(n) = (p-1)(q-1)</p>
</blockquote>
<p>爱丽丝算出φ(3233)等于60×52，即3120。</p>
<p>第四步，随机选择一个整数e，条件是1</p>
<p>爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）</p>
<p>第五步，计算e对于φ(n)的模反元素d。</p>
<p>所谓<a href="http://zh.wikipedia.org/wiki/模反元素" target="_blank" rel="noopener">“模反元素”</a>就是指有一个整数d，可以使得ed被φ(n)除的余数为1。</p>
<blockquote>
<p>ed ≡ 1 (mod φ(n))</p>
</blockquote>
<p>这个式子等价于</p>
<blockquote>
<p>ed - 1 = kφ(n)</p>
</blockquote>
<p>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。</p>
<blockquote>
<p>ex + φ(n)y = 1</p>
</blockquote>
<p>已知 e=17, φ(n)=3120，</p>
<blockquote>
<p>17x + 3120y = 1</p>
</blockquote>
<p>这个方程可以用<a href="http://zh.wikipedia.org/wiki/扩展欧几里得算法" target="_blank" rel="noopener">“扩展欧几里得算法”</a>求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。</p>
<p>至此所有计算完成。</p>
<p>第六步，将n和e封装成公钥，n和d封装成私钥。</p>
<p>在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。</p>
<p>实际应用中，公钥和私钥的数据都采用<a href="http://zh.wikipedia.org/zh-cn/ASN.1" target="_blank" rel="noopener">ASN.1</a>格式表达（<a href="http://hi.baidu.com/mathack/item/d0ad4cc1514a3663f7c95da2" target="_blank" rel="noopener">实例</a>）。</p>
<h3 id="RSA的可靠性以及破解"><a href="#RSA的可靠性以及破解" class="headerlink" title="RSA的可靠性以及破解"></a>RSA的可靠性以及破解</h3><p>回顾上面的密钥生成步骤，一共出现六个数字：</p>
<blockquote>
<p>p<br>　　q<br>　　n<br>　　φ(n)<br>　　e<br>　　d</p>
</blockquote>
<p>这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。</p>
<p>那么，有无可能在已知n和e的情况下，推导出d？</p>
<blockquote>
<p>（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</p>
<p>（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</p>
<p>（3）n=pq。只有将n因数分解，才能算出p和q。</p>
</blockquote>
<p>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。</p>
<p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：</p>
<blockquote>
<p>“对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。</p>
<p>假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。</p>
<p>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。”</p>
</blockquote>
<p>举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。</p>
<blockquote>
<p>​       12301866845301177551304949<br>　　58384962720772853569595334<br>　　79219732245215172640050726<br>　　36575187452021997864693899<br>　　56474942774063845925192557<br>　　32630345373154826850791702<br>　　61221429134616704292143116<br>　　02221240479274737794080665<br>　　351419597459856902143413</p>
</blockquote>
<p>它等于这样两个质数的乘积：</p>
<blockquote>
<p>​       33478071698956898786044169<br>　　84821269081770479498371376<br>　　85689124313889828837938780<br>　　02287614711652531743087737<br>　　814467999489<br>　　　　×<br>　　36746043666799590428244633<br>　　79962795263227915816434308<br>　　76426760322838157396665112<br>　　79233373417143396810270092<br>　　798736308917</p>
</blockquote>
<p>事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。</p>
<h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h3><p>有了公钥和密钥，就能进行加密和解密了。</p>
<p>（1）加密要用公钥 (n,e)</p>
<p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p>
<p>所谓”加密”，就是算出下式的c：</p>
<blockquote>
<p>me ≡ c (mod n)</p>
</blockquote>
<p>爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：</p>
<blockquote>
<p>6517 ≡ 2790 (mod 3233)</p>
</blockquote>
<p>于是，c等于2790，鲍勃就把2790发给了爱丽丝。</p>
<p>（2）解密要用私钥(n,d)</p>
<p>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：</p>
<blockquote>
<p>cd ≡ m (mod n)</p>
</blockquote>
<p>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出</p>
<blockquote>
<p>27902753 ≡ 65 (mod 3233)</p>
</blockquote>
<p>因此，爱丽丝知道了鲍勃加密前的原文就是65。</p>
<p>至此，”加密–解密”的整个过程全部完成。</p>
<p>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。</p>
<p>你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如<a href="https://zh.wikipedia.org/wiki/资料加密标准" target="_blank" rel="noopener">DES</a>），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</p>
<p>但是RSA比较慢，rsa慢在他以幂模运算为基础，也就是c^e mod N。</p>
<h3 id="解密和加密的证明"><a href="#解密和加密的证明" class="headerlink" title="解密和加密的证明"></a>解密和加密的证明</h3><p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：</p>
<blockquote>
<p>cd ≡ m (mod n)</p>
</blockquote>
<p>因为，根据加密规则</p>
<blockquote>
<p>ｍe ≡ c (mod n)</p>
</blockquote>
<p>于是，c可以写成下面的形式：</p>
<blockquote>
<p>c = me - kn</p>
</blockquote>
<p>将c代入要我们要证明的那个解密规则：</p>
<blockquote>
<p>(me - kn)d ≡ m (mod n)</p>
</blockquote>
<p>它等同于求证</p>
<blockquote>
<p>med ≡ m (mod n)</p>
</blockquote>
<p>由于</p>
<blockquote>
<p>ed ≡ 1 (mod φ(n))</p>
</blockquote>
<p>所以</p>
<blockquote>
<p>ed = hφ(n)+1</p>
</blockquote>
<p>将ed代入：</p>
<blockquote>
<p>mhφ(n)+1 ≡ m (mod n)</p>
</blockquote>
<p>接下来，分成两种情况证明上面这个式子。</p>
<p>（1）m与n互质。</p>
<p>根据欧拉定理，此时</p>
<blockquote>
<p>mφ(n) ≡ 1 (mod n)</p>
</blockquote>
<p>得到</p>
<blockquote>
<p>(mφ(n))h × m ≡ m (mod n)</p>
</blockquote>
<p>原式得到证明。</p>
<p>（2）m与n不是互质关系。</p>
<p>此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。</p>
<p>以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：</p>
<blockquote>
<p>(kp)q-1 ≡ 1 (mod q)</p>
</blockquote>
<p>进一步得到</p>
<blockquote>
<p>[(kp)q-1]h(p-1) × kp ≡ kp (mod q)</p>
</blockquote>
<p>即</p>
<blockquote>
<p>(kp)ed ≡ kp (mod q)</p>
</blockquote>
<p>将它改写成下面的等式</p>
<blockquote>
<p>(kp)ed = tq + kp</p>
</blockquote>
<p>这时t必然能被p整除，即 t=t’p</p>
<blockquote>
<p>(kp)ed = t’pq + kp</p>
</blockquote>
<p>因为 m=kp，n=pq，所以</p>
<blockquote>
<p>med ≡ m (mod n)</p>
</blockquote>
<p>原式得到证明。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>fishhook原理</title>
    <url>/2020/05/11/fishhook%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="fishhook简介"><a href="#fishhook简介" class="headerlink" title="fishhook简介"></a>fishhook简介</h3><p>fishhook 是一个由 facebook 开源的第三方框架，其主要作用就是<strong>动态修改 C 语言函数实现</strong>。</p>
<p>这个框架的代码其实非常的简单，只包含两个文件：<code>fishhook.c</code> 以及 <code>fishhook.h</code>；两个文件所有的代码加起来也不超过 300 行。</p>
<p> 不过它的实现原理是非常有意思并且精妙的，不过在这之前，先让我们简单尝试一下</p>
<h3 id="Fishhook-简单使用"><a href="#Fishhook-简单使用" class="headerlink" title="Fishhook 简单使用"></a>Fishhook 简单使用</h3><p>例如，我hook一个系统的NSLog方法，大概的代码就是这样</p>
<blockquote>
<p>1.写一个自己的func来做hook的事，例如文中的MYLog</p>
<p>2.定义一个函数指针用来保存被hook的函数，方便后续调用</p>
<p>3.创建一个<code>rebinding</code>结构体，给三个参数赋值，然后调用<code>rebind_symbols</code>，一个hook就已经完成</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)hook</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> <span class="title">logRebind</span>;</span></span><br><span class="line">    logRebind.name = <span class="string">"NSLog"</span>;</span><br><span class="line">    logRebind.replacement = MyLog;</span><br><span class="line">    logRebind.replaced = (<span class="keyword">void</span> *)&amp;originalNSLog;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> <span class="title">rebs</span>[] = &#123;</span>logRebind&#125;;    </span><br><span class="line">    rebind_symbols(rebs, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*originalNSLog)</span><span class="params">(NSString *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLog</span><span class="params">(NSString *format, ...)</span></span>&#123;</span><br><span class="line">    <span class="comment">// do sth you  want</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// orignal func</span></span><br><span class="line">    originalNSLog(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信有很多人和我一样有一些不解，OC的runtime是基于OC动态运行时的本质做了交换，但是NSLog是一个C语言函数，是静态的。这是如何做到的呢？这些可以在fishhook的源码中可以找到，不过在这之前，我们先补充一点基础 知识</p>
<h3 id="前瞻理论"><a href="#前瞻理论" class="headerlink" title="前瞻理论"></a>前瞻理论</h3><p>我们上面示例代码中，NSLog是一个属于Foundation的库的函数，在编译过程中，其实他并不在我们文件中。对于我们应用程序来说，本质是一个二进制执行文件，有个更专业的词，叫<a href="https://zh.wikipedia.org/wiki/Mach-O" target="_blank" rel="noopener">MachO</a>,当<a href="https://zh.wikipedia.org/wiki/Mach-O" target="_blank" rel="noopener">MachO</a>被内核加载到内存中开始运行时，有一个叫<a href="https://en.wikipedia.org/wiki/Dynamic_linker" target="_blank" rel="noopener">DYLD</a>做了一系列的事情，其中一步叫做加载共享缓存区(shareCache),DYLD做了一系列的加载链接。那么苹果如果在编译时保证这种并不确定的静态呢，苹果为了能在 Mach-O 文件中访问外部函数，采用了一个技术，叫做<a href="https://en.wikipedia.org/wiki/Position-independent_code" target="_blank" rel="noopener">PIC</a>（位置代码独立）技术。</p>
<p>当你的应用程序想要调用 Mach-O 文件外部的函数的时候，或者说如果 Mach-O 内部需要调用系统的库函数时，Mach-O 文件会：</p>
<blockquote>
<ol>
<li>先在 Mach-O 文件的 _DATA 段中建立一个指针,这个指针变量指向外部函数。</li>
<li>DYLD 会动态的进行绑定！将 Mach-O 中的 _DATA 段中的指针，指向外部函数。</li>
</ol>
</blockquote>
<p>fishhook本质就是找这个符号名，已经把这个符号名的符号给替换掉的过程，下面可以通过2张图简单了解一下</p>
<h3 id="Fishhook-原理简单图解"><a href="#Fishhook-原理简单图解" class="headerlink" title="Fishhook 原理简单图解"></a>Fishhook 原理简单图解</h3><p>1.寻址,本质就是对MachO文件中的几个表的对应关系的查找，感兴趣的可以深入的了解下MachO,后面的源码也会简单的说明</p>
<p><img src="https://camo.githubusercontent.com/18243516844d12b1bd158ce3687635d6e48d2e2e/687474703a2f2f692e696d6775722e636f6d2f4856587148437a2e706e67" alt="Visual explanation"></p>
<p>2.替换</p>
<p><img src="/2020/05/11/fishhook%E5%8E%9F%E7%90%86/simpleTheory.png" alt="simpleTheory"></p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>首先入口函数<code>rebind_symbols</code>,接受一个<code>rebinding</code>结构体的数组，以及他的数组长度。可以一次hook多个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册重新绑定符号的回调时机</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将需要hook的结构体链接成链表结构(之所以使用链表是因为在C语言中，处理这种预先不知道可能有多少个的集合来讲，链表是比较好的选择)</span></span><br><span class="line">  <span class="keyword">int</span> retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    <span class="comment">//此处的异常主要用来处理malloc开辟空间失败</span></span><br><span class="line">  <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If this was the first call, register callback for image additions (which is also invoked for</span></span><br><span class="line">  <span class="comment">// existing images, otherwise, just run on existing images</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果是第一次调用重新绑定符号的方法，就通过注册添加image(target module)的方法回调来重新绑定符号(这个方法在任何地方注册都会执行加载image的回调);</span></span><br><span class="line"><span class="comment">     如果不是第一次调用重新绑定符号的方法，就通过遍历当前已经加载的image来循环绑定符号(如果在此操作执行之后，又重新加载了image，可以通过_dyld_register_func_for_add_image来监听到);</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在方法内部调用rebind_symbols_for_image实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> struct mach_header *header,</span><br><span class="line">                                      <span class="keyword">intptr_t</span> slide) &#123;</span><br><span class="line">    rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取链接表，符号表，动态符号表，重定向(<a href="[https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9D%80%E7%A9%BA%E9%96%93%E9%85%8D%E7%BD%AE%E9%9A%A8%E6%A9%9F%E8%BC%89%E5%85%A5](https://zh.wikipedia.org/wiki/位址空間配置隨機載入)">ASLR</a>)表在内存中的地址，获取<strong>la_symbol_ptr以及</strong>ln_symbol_ptr对应的section，方便找到后续的对应的两个表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> struct mach_header *header,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">intptr_t</span> slide)</span> </span>&#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一次遍历load Commands主要是为了找到链接表linkedit_segment,符号表(symtab_cmd),动态符号表(dysymtab_cmd)对应的load command</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);<span class="comment">//使用uintptr_t类型主要是为了方便按照字节为单位移动指针的位置</span></span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 通过使用__LINKEDIT的起始地址找到symbol table/string table在内存中的地址</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  <span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff); <span class="comment">//使用char *类型是因为字符在内存中按照char为单位进行存储</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取重定向表在内存中的位置</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff); <span class="comment">//使用uint32_t *是因为重定向符号表中数据按照4字节为单位进行存储</span></span><br><span class="line"> </span><br><span class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">       <span class="comment">//找到DATA和DATA_CONST segment，并跳过</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">////找到__nl_symbol_ptr和__la_symbol_ptr这两个section</span></span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        <span class="keyword">section_t</span> *sect =</span><br><span class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">            <span class="comment">//遍历懒加载符号表中的符号，与_rebindings_head进行比较，对匹配的符号进行重新绑定</span></span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">            <span class="comment">//遍历非懒加载符号表中的符号，与_rebindings_head进行比较，对匹配的符号进行重新绑定</span></span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找并替换_rebindings_head中需要替换的符号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">section_t</span> *section,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">nlist_t</span> *symtab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">char</span> *strtab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">uint32_t</span> *indirect_symtab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//section在indirect table中的索引从reserved1处开始</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">    <span class="comment">// //indirect Symbols中包含了各个section中符号在Symbol Table的index，这里是直接定位到对应__DATA,__la_symbol_ptr所在的index数组</span></span><br><span class="line">  <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;<span class="built_in">size</span> / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</span><br><span class="line">      <span class="comment">//获取indirext table中对应索引处的值，该值表示在symbole table中的索引</span></span><br><span class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">      <span class="comment">//如果该索引表示的符号是未绑定前的符号或者本地符号，则不进行任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//获取在string table中偏移</span></span><br><span class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">      <span class="comment">//获取在string table中的地址</span></span><br><span class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></span><br><span class="line">      <span class="comment">//遍历找到需要重新绑定的符号,进行重新绑定</span></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(symbol_name) &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//防止重复绑定</span></span><br><span class="line">          <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">              <span class="comment">//如果符号对应的实现不是自定义实现，说明符号没有还重新绑定，将符号对应的真实实现存入cur-&gt;rebindings[j].replaced对应位置</span></span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="comment">//将自定义实现，存入符号对应的位置</span></span><br><span class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">            <span class="comment">// 跳出，避免多次绑定</span></span><br><span class="line">          <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否能hook在项目或者静态库中的定义的C函数"><a href="#是否能hook在项目或者静态库中的定义的C函数" class="headerlink" title="是否能hook在项目或者静态库中的定义的C函数"></a>是否能hook在项目或者静态库中的定义的C函数</h3><p>答案是不能！！！因为无论在项目中还是静态库中的函数，在编译的时候它们的地址就已经确定(Mach-O基地址+偏移)，它们不会存在于<code>__la_symbol_ptr</code>表中，自然也就无法更改。</p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
  </entry>
</search>
