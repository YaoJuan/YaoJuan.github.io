<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Category的结构探究</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/Category%E7%9A%84%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在之前研究fishhook的时候有碰过一点点dyld加载的知识，当时惊鸿一瞥到了类的加载，也看到了分类的加载。只记得加载镜像之后的一些处理，大体对于分类还是有点迷迷糊糊，所以借着学习的机会走一次源码看看</p>
<h4 id="Category的使用"><a href="#Category的使用" class="headerlink" title="Category的使用"></a>Category的使用</h4><p>一般我们为了对业务的拆分或者一些其他的要求，要对一些原有的类进行加强，我们一般会写分类。在其中可以定义方法的声明和实现。也可以写properties，但是注意properties只会生成对应的set和get的声明，并不会有成员变量和对应方法的实现。所以我们一边是搭配着AssociatedObject来使用的</p>
<h4 id="Category的底层结构"><a href="#Category的底层结构" class="headerlink" title="Category的底层结构"></a>Category的底层结构</h4><p>想要获取Category的底层结构很简单，可以直接在项目中定义一个分类，然后通过clang来手动编译成c++，然后查看对应的.mm文件就可以看到。但是我们有一个更简单的办法，直接查看源码，结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>里面保存了类名，实力方法、类方法、协议、以及变量。注意的是这里的变量并不会真正的存变量。其实看到这个结构我们很熟悉，其中几个变量和之前的类的结构体很相似，我个人猜想是在运行时把这些类附加到对应的类的结构体以及元类结构体中。可以从大概的代码中验证一下</p>
<h4 id="Category的加载"><a href="#Category的加载" class="headerlink" title="Category的加载"></a>Category的加载</h4><p>我们可以从lldb加载镜像一直跟起，跟到加载分类的函数，源码实现是这这个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* remethodizeClass</span></span><br><span class="line"><span class="comment">* Attach outstanding categories to an existing class.</span></span><br><span class="line"><span class="comment">* Fixes up cls's method list, protocol list, and property list.</span></span><br><span class="line"><span class="comment">* Updates method caches for cls and its subclasses.</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock must be held by the caller</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"CLASS: attaching categories to class '%s' %s"</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        <span class="built_in">free</span>(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注释我们也可以看出，这是要做附加分类的工作了，继续跟一步看</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Attach method lists and properties and protocols from categories to a class.</span></span><br><span class="line"><span class="comment">// Assumes the categories in cats are all loaded and sorted by load order, </span></span><br><span class="line"><span class="comment">// oldest categories first.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count;</span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = </span><br><span class="line">            entry.cat-&gt;propertiesForMeta(isMeta, entry.hi);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data();</span><br><span class="line"></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount, NO, fromBundle);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount);</span><br><span class="line">    <span class="built_in">free</span>(mlists);</span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) flushCaches(cls);</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount);</span><br><span class="line">    <span class="built_in">free</span>(proplists);</span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount);</span><br><span class="line">    <span class="built_in">free</span>(protolists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之就是就是迭代所有的分类，然后把分类中的变量，方法，协议分别调用attachLists来做附加。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void attachLists(List* const * addedLists, uint32_t addedCount) &#123;</span><br><span class="line">    if (addedCount &#x3D;&#x3D; 0) return;</span><br><span class="line"></span><br><span class="line">    if (hasArray()) &#123;</span><br><span class="line">        &#x2F;&#x2F; many lists -&gt; many lists</span><br><span class="line">        uint32_t oldCount &#x3D; array()-&gt;count;</span><br><span class="line">        uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count &#x3D; newCount;</span><br><span class="line">        memmove(array()-&gt;lists + addedCount, array()-&gt;lists, </span><br><span class="line">                oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!list  &amp;&amp;  addedCount &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &#x2F;&#x2F; 0 lists -&gt; 1 list</span><br><span class="line">        list &#x3D; addedLists[0];</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 1 list -&gt; many lists</span><br><span class="line">        List* oldList &#x3D; list;</span><br><span class="line">        uint32_t oldCount &#x3D; oldList ? 1 : 0;</span><br><span class="line">        uint32_t newCount &#x3D; oldCount + addedCount;</span><br><span class="line">        setArray((array_t *)malloc(array_t::byteSize(newCount)));</span><br><span class="line">        array()-&gt;count &#x3D; newCount;</span><br><span class="line">        if (oldList) array()-&gt;lists[addedCount] &#x3D; oldList;</span><br><span class="line">        memcpy(array()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单看一下就是把原来存在的协议，方法都进行了后移，然后把分类对应的这些东西放在最前面。</p>
<p>这里引出一个问题，如果在类和分类中同时实现了一个方法。根据上面这个附加逻辑，明显就是会调用分类的，但是请注意这并不是覆盖。而只是在方法列表中，分类的同名方法在类的前面，所有在查找imp的时候先找到的是分类的，所以就会调用分类的</p>
<h4 id="Category的Load方法"><a href="#Category的Load方法" class="headerlink" title="Category的Load方法"></a>Category的Load方法</h4><p>我们知道所有的类会在应用跑起来的时候都会执行一次load方法，这是dyld在加载完所有image,然后加载类的时候做的事情。那么如果在分类中写load呢，其实尝试一下发现分类的load也是会调用的。</p>
<p>而且会发现一个奇怪的事情，类原本的load也会调用。这似乎不符合我们上面一张最后那个方法“覆盖”的逻辑。关于这一点也只是查看源码进一步求证</p>
<p>我们首先找到要调用load方法的地方</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">load_images(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Return without taking locks if there are no +load methods here.</span></span><br><span class="line">    <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">recursive_mutex_locker_t</span> <span class="title">lock</span><span class="params">(loadMethodLock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">rwlock_writer_t</span> <span class="title">lock2</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实prepare_load_methods里面就做了一些预添加以及添加分类的操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要一点我们要看看schedule_class_load</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这是一个递归调用，递归将类加载到loadable_list中，并且永远是先加载父类再加载子类，做完这些处理之后我们就有2个有顺序的表，class和category，并且根据先后加载以及父类的关系做了排序</p>
<p>然后分别调用load方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到先调用的类，调用完了所有的类，然后再调用分类的load。但是这并不能解决我们为什么方法没有覆盖的问题。于是再点进看一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现他拿到load方法的指针并不是通过msg_send。而是直接通过.method的指针拿到的，所有并不会有查找的过程，而是简单粗暴的通过地址直接取，然后调用。分类中的代码大同小异，就不展开了</p>
<h4 id="Category的initialize"><a href="#Category的initialize" class="headerlink" title="Category的initialize"></a>Category的initialize</h4><p>相对于load,有另外一个方法也很相似，也是只会调用一次。就是initialize。这个方法会在类对象第一次收到消息时调用。关于这一点也找证实一下</p>
<p>我们可以去查看objc_msgSend的源码,但是很遗憾，这里全部都是汇编来实现的。而且并没有看到initialize的踪迹。</p>
<p>但是我们都知道发送消息之前需要查找消息，很不信，这也是用汇编实现的。但是跟着汇编的函数最终还是会有一个c的函数调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation</span><span class="params">(Class cls, SEL sel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls  ||  !sel) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    imp = lookUpImpOrNil(cls, sel, nil, </span><br><span class="line">                         YES<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Translate forwarding function to C-callable external version</span></span><br><span class="line">    <span class="keyword">if</span> (!imp) &#123;</span><br><span class="line">        <span class="keyword">return</span> _objc_msgForward;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进去，方法太长，我们只截取部分和注释</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">***********************************************************************</span><br><span class="line">* lookUpImpOrForward.</span><br><span class="line">* The standard IMP lookup. </span><br><span class="line">* initialize==NO tries to avoid +initialize (but sometimes fails)</span><br><span class="line">* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)</span><br><span class="line">* Most callers should use initialize==YES <span class="keyword">and</span> cache==YES.</span><br><span class="line">* inst is an instance of cls <span class="keyword">or</span> a subclass thereof, <span class="keyword">or</span> nil <span class="keyword">if</span> none is known. </span><br><span class="line">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span><br><span class="line">* May <span class="keyword">return</span> _objc_msgForward_impcache. IMPs destined <span class="keyword">for</span> external use </span><br><span class="line">*   must be converted to _objc_msgForward <span class="keyword">or</span> _objc_msgForward_stret.</span><br><span class="line">*   If you don<span class="number">'</span>t want forwarding at all, use lookUpImpOrNil() instead.</span><br><span class="line">**********************************************************************/</span><br><span class="line">IMP lookUpImpOrForward(Class cls, SEL sel, id inst, </span><br><span class="line">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)&#123;</span><br><span class="line">  ....</span><br><span class="line">        <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.<span class="built_in">read</span>();</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到需要初始化，并且没有被初始化的时候就会去初始化,_class_initialize部分实现如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* class_initialize.  Send the '+initialize' message on demand to any</span></span><br><span class="line"><span class="comment">* uninitialized class. Force initialization of superclasses first.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _class_initialize(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="keyword">bool</span> reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure super is done initializing BEFORE beginning to initialize cls.</span></span><br><span class="line">    <span class="comment">// See note about deadlock above.</span></span><br><span class="line">    supercls = cls-&gt;superclass;</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/// 省略</span></span><br><span class="line">  callInitialize(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然这是一个递归调用，也是会先初始化父类。到最终会执行到callInitialize</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到代码，是通过objc_msgSend来调用的initialize。所以我们肯定有答案了，也会做类似”覆盖”的操作</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>到最后，我们可以总结一下load和initialize的调用顺序</p>
<h6 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h6><ul>
<li>+load方法会在runtime加载类、分类时调用</li>
<li>先调用类的+load</li>
<li>按照编译先后顺序调用（先编译，先调用）</li>
<li>调用子类的+load之前会先调用父类的+load</li>
<li>所有类的load调用完成再调用分类的+load</li>
<li>按照编译先后顺序调用（先编译，先调用）</li>
</ul>
<h6 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize"></a>Initialize</h6><ul>
<li>+initialize方法会在类第一次接收到消息时调用</li>
<li>先调用父类的+initialize，再调用子类的+initialize</li>
<li>+initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，所以有以下特点<ol>
<li>如果子类没有实现+initialize，会调用父类的+initialize</li>
<li>如果分类实现了+initialize，就覆盖类本身的+initialize调用</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>AssociatedObject</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/AssociatedObject/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在之前看过对象和类对象的的结构之后，我们知道objc_class中有一个变量的内部变量是专门保存属性的，是一个property_list_t 的指针类型。这个理解起来很简单，就是装在了所有的成员变量。但是我们有用过标题AssociatedObject这个api来给分类添加成员变量。那么添加之后是不是也在这里呢。今天就基于这个来探究一下</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>因为分类底层结构的限制(后面单独说下分类的结构，本质也是结构体)，不能添加成员变量到分类中。但可以通过关联对象来间接实现</p>
<ul>
<li><p>添加关联对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void * key,</span><br><span class="line">                                id value, objc_AssociationPolicy policy)</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得关联对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id objc_getAssociatedObject(id object, const void * key)</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除所有的关联对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h6 id="AssociationPolicy"><a href="#AssociationPolicy" class="headerlink" title="AssociationPolicy"></a><strong>AssociationPolicy</strong></h6><p>其实对应的就是我们创建成员变量的一些关键字。</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/AssociatedObject/AssociatedObject1.png" alt="AssociatedObject"></p>
<h4 id="源码管中窥豹"><a href="#源码管中窥豹" class="headerlink" title="源码管中窥豹"></a>源码管中窥豹</h4><p>我们直接看runtime的开源部分，找到对应的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span> </span>&#123;</span><br><span class="line">    _object_set_associative_reference(object, (<span class="keyword">void</span> *)key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(id object, <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="function">ObjcAssociation <span class="title">old_association</span><span class="params">(<span class="number">0</span>, nil)</span></span>;</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.<span class="built_in">find</span>(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;<span class="built_in">find</span>(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> &#123;</span></span><br><span class="line">    <span class="comment">// associative references: object pointer -&gt; PtrPtrHashMap.</span></span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AssociationsManager()   &#123; AssociationsManagerLock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; AssociationsManagerLock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</span><br><span class="line">            _map = <span class="keyword">new</span> AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>尽管代码看起来很绕，但是我们可以看到其中第一步就是拿到一个mannager,然后拿到其中的一个变量。然后做了2次内层迭代找到对应的key赋值的。其实这里面就有几个关键的类</p>
<ul>
<li>AssociationsManager</li>
<li>AssociationsHashMap</li>
<li>ObjectAssociationMap</li>
<li>ObjcAssociation</li>
</ul>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/AssociatedObject/AssociatedObject2.png" alt="AssociatedObject"></p>
<p>其实看代码是能找出这之间的包含关系的<br><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/AssociatedObject/AssociatedObject3.png" alt="AssociatedObject"></p>
<p>同样的，取值也是通过这样的方式来取的。但是从源码的else我们可以注意到一点，当给一个AssociatedObject设为nil时，会执行erase操作。也就是清除这个关联对象</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>可以回到我们的问题，其实AssociatedObject的添加并不是添加到对应类对象的结构体成员变量中的，而且进程中，所有的关联对象被统一保存在mananger的一个hashmap中，然后通过对象地址取得对象的关联hashmap,再通过key从hashmap中拿到对应的Association,然后做处理</p>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>KVO和KVC</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/KVO%E5%92%8CKVC/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>其实很早之前就接触过kvo了，知道是通过派生类以及钩子一起实现，但是还是好奇想证实一下。kvc也大概知道是从一些键值对来取值赋值，但是老是忘，所以干脆写一篇博客总结一下</p>
<h4 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h4><p>KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变,大概的使用代码如下</p>
<h6 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">    Person *p1 &#x3D; [[Person alloc] init];</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    self.p1 &#x3D; p1;</span><br><span class="line">    NSLog(@&quot;%p&quot;,p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    self.p1.age &#x3D; 20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    if ([keyPath  isEqual: @&quot;age&quot;]) &#123;</span><br><span class="line">        NSLog(@&quot;%p的new value &#x3D; %zd,old value &#x3D; %zd&quot;,object,[change[@&quot;new&quot;] integerValue] ,[change[@&quot;old&quot;] integerValue]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用addobserver方法来监听哪个对象，由哪个对象监听。监听什么变量，以及一些options和context来传递参数</li>
<li>在监听对象的上下文里调用observeValueForKeyPath来监听。通过对应的参数取值</li>
</ol>
<h6 id="KVO的探索"><a href="#KVO的探索" class="headerlink" title="KVO的探索"></a>KVO的探索</h6><p>当我再创建一个对象p2，同样的在改变p1的同时也改变p2的值，但是我不监听p2的改变。如预期一样，在观察函数中并没有收到p2改变的信息。</p>
<p>尽管结果如我预期，但是我还是好奇，其实2个对象都只是执行了set方法，为什么一个会走监听一个不会走监听呢？基于之前说过一个是派生类，于是我决定打印一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    &#x2F;&#x2F; Do any additional setup after loading the view.</span><br><span class="line">    Person *p1 &#x3D; [[Person alloc] init];</span><br><span class="line">    [p1 addObserver:self forKeyPath:@&quot;age&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    self.p1 &#x3D; p1;</span><br><span class="line">    </span><br><span class="line">    Person *p2 &#x3D; [[Person alloc] init];</span><br><span class="line">    self.p2 &#x3D; p2;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;p1的地址为%p,p2的地址为%p&quot;,p1, p2);</span><br><span class="line">    NSLog(@&quot;p1的class为%@,p2的class为%@&quot;,NSStringFromClass(p1.class), NSStringFromClass(p2.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/KVO%E5%92%8CKVC/kvo1.png" alt="KVO和KVC"></p>
<p>但是并没有得到我想要的结果，但是因为之前获取内存那里用不同的api得到了不同结果，吸取教训。我用其他的api试试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;p1的class为%@,p2的class为%@&quot;,NSStringFromClass(object_getClass(p1)), NSStringFromClass(object_getClass(p2)));</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/KVO%E5%92%8CKVC/kvo2.png" alt="KVO和KVC"></p>
<p>果然，p1在添加观察者之后他的类名变了。而且这个类显然不是由系统创建的，这个可以提前说一下，是runtime调用api动态创建的。另外，在前面一章我们知道对象的isa是指向类对象的。所以应该是创建了一个新类对象，然后改变了isa的指向。另外我们也说过，是通过isa去找类对象里的方法实现(因为调用的是setAge，是个对象方法)。所以我想分别再打印一下他们的imp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IMP imp1 &#x3D; [p1 methodForSelector:@selector(setAge:)];</span><br><span class="line">IMP imp2&#x3D; [p2 methodForSelector:@selector(setAge:)];</span><br><span class="line">NSLog(@&quot;p1的实现是%p，p2的实现是%p&quot;,imp1,imp2);</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/KVO%E5%92%8CKVC/kvo3.png" alt="KVO和KVC"></p>
<p>结果大出意料，被监听的对象的imp也成了一个c语言函数，通过函数名很好理解，设了一个longlong类型并且通知，所以可以猜测得到如果监听到其他类型应该也有对应函数的实现。其实这一点我们可以搜索一下，我们可以直接在foundation框架通过关键字搜索。首先手动用clang手动编译并且链接Foundation，然后调用nm 命令来通过关键字ValueAndNotify来查找，结果如下<img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/KVO%E5%92%8CKVC/kvo4.png" alt="KVO和KVC"></p>
<p>所以我们也可以推算这个是看碟下菜，什么类型就调用对应的函数</p>
<h6 id="派生类的内部探究"><a href="#派生类的内部探究" class="headerlink" title="派生类的内部探究"></a>派生类的内部探究</h6><p>另外，我想跟进一步看看这个派生类，所以就干脆利用runtime来打印所有的iv ars和方法名。结果总结成图是这个样子</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/KVO%E5%92%8CKVC/kvo5.png" alt="KVO和KVC"></p>
<p>由于里面重写了class，所以就造成了我们开始调用class发现没有改变的事实，其实我猜测就是为了封装性，因为对于正在编写代码的你我来说，并不需要知道知道他是什么类，他有person类的一些特质，我们就把它当成person类。也方便我们做一些类型比较。</p>
<h6 id="NSSetIntValueAndNotify的实现"><a href="#NSSetIntValueAndNotify的实现" class="headerlink" title="NSSetIntValueAndNotify的实现"></a>NSSetIntValueAndNotify的实现</h6><p>我们目前只知道了他变相Hook了原始方法为一个c语言的函数，但是我们还是想知道具体的实现。由于之前学过逆向，这个也不难，找到越狱机，导出sharecache，这里就有foudation的实现。通过ida来反汇编，可以通过汇编来看出一些端倪。这里就不具体展示，直接总结了</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/KVO%E5%92%8CKVC/kvo6.png" alt="KVO和KVC"></p>
<p>大概就是这样，kvo对外的通知其实就是通过3句函数来实现的，在will和did之间完成赋值操作。外界就会收到observer的改变</p>
<ul>
<li>调用willChangeValueForKey:</li>
<li>调用原来的setter实现</li>
<li>调用didChangeValueForKey:</li>
<li>didChangeValueForKey:内部会调用observer的observeValueForKeyPath:ofObject:change:context:方法</li>
</ul>
<h4 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h4><p>相对于KVO来说KVC就简单许多，KVC的全称是Key-Value Coding，俗称“键值编码”，可以通过一个key来访问(获取、设值)某个属性</p>
<h6 id="KVC的使用"><a href="#KVC的使用" class="headerlink" title="KVC的使用"></a>KVC的使用</h6><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br></pre></td></tr></table></figure>

<h6 id="KVC的函数寻找途径"><a href="#KVC的函数寻找途径" class="headerlink" title="KVC的函数寻找途径"></a>KVC的函数寻找途径</h6><p>其实这个在kvc的官方文档就有写，就用图来表示</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/KVO%E5%92%8CKVC/kvo7.png" alt="KVO和KVC"></p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/KVO%E5%92%8CKVC/kvo8.png" alt="KVO和KVC"></p>
<h6 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h6><p>通过实践得知，我们就算不通过property的方式来生成成员变量，而是直接手动生成属性。尽管这样不会生成set,get方法。通过kvc去赋值成功之后也会触发kvo。因为我们之前说过,kvo的本质还是通过willchange 和didchange之间的组合来做的操作，kvc在做赋值时自己做了对应的实现。切不可把kvo直接等价于set变量的hook实现</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过一系列探究，我们知道了kvo的具体实现，以及派生类的内部，并且知道了kvo支持的数据类型。以及kvc的一些寻值路径。特别要记住一点，kvc会自动触发kvo,尽管没有set方法</p>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>NSThead和内核线程的转换</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/NSThead%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在最近的一个需求中，需要把NSThread转换成内核线程，所以就对这部分了解了一下，也有了这篇文章</p>
<h3 id="Mach-线程"><a href="#Mach-线程" class="headerlink" title="Mach 线程"></a>Mach 线程</h3><p>iOS 是基于 Apple Darwin 内核，由 kernel、XNU 和 Runtime 组成，而 XNU 是 Darwin 的内核，它是“X is not UNIX”的缩写，是一个混合内核，由 Mach 微内核和 BSD 组成。Mach 内核是轻量级的平台，只能完成操作系统最基本的职责，比如：进程和线程、虚拟内存管理、任务调度、进程通信和消息传递机制。其他的工作，例如文件操作和设备访问，都由 BSD 层实现。</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/NSThead%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BD%AC%E6%8D%A2/mach_thread.png" alt="mach_thread"></p>
<h3 id="NSThead的层级封装"><a href="#NSThead的层级封装" class="headerlink" title="NSThead的层级封装"></a>NSThead的层级封装</h3><p>很多文章都提到了 NSThread 是 pthread 的封装，这就涉及两个问题:</p>
<blockquote>
<ol>
<li>pthread 是什么</li>
<li>NSThread 如何封装 pthread</li>
</ol>
</blockquote>
<p>pthread 中的字母 p 是 POSIX 的简写，POSIX 表示 “可移植操作系统接口(Portable Operating System Interface)”。</p>
<p>每个操作系统都有自己的线程模型，不同操作系统提供的，操作线程的 API 也不一样，这就给跨平台的线程管理带来了问题，而 POSIX 的目的就是提供抽象的 pthread 以及相关 API，这些 API 在不同操作系统中有不同的实现，但是完成的功能一致。</p>
<p>Unix 系统提供的 <code>thread_get_state</code> 和 <code>task_threads</code> 等方法，操作的都是内核线程，每个内核线程由 <code>thread_t</code> 类型的 id 来唯一标识，pthread 的唯一标识是 <code>pthread_t</code> 类型。</p>
<p>内核线程和 pthread 的转换(也即是 <code>thread_t</code> 和 <code>pthread_t</code> 互转)很容易，因为 pthread 诞生的目的就是为了抽象内核线程。</p>
<p>NSThread 的 <code>start</code> 方法简化版实现如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) start &#123;</span><br><span class="line">  <span class="keyword">pthread_attr_t</span>    attr;</span><br><span class="line">  <span class="keyword">pthread_t</span>        thr;</span><br><span class="line">  errno = <span class="number">0</span>;</span><br><span class="line">  pthread_attr_init(&amp;attr);</span><br><span class="line">  <span class="keyword">if</span> (pthread_create(&amp;thr, &amp;attr, nsthreadLauncher, self)) &#123;</span><br><span class="line">      <span class="comment">// Error Handling</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NSThread-转内核-thread"><a href="#NSThread-转内核-thread" class="headerlink" title="NSThread 转内核 thread"></a>NSThread 转内核 thread</h3><p>由于系统没有提供相应的转换方法，而且 NSThread 没有保留线程的 <code>pthread_t</code>，所以常规手段无法满足需求。</p>
<p>上文提到了利用 <code>pthread_create</code> 方法创建线程，它的回调函数 <code>nsthreadLauncher</code> 实现如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *nsthreadLauncher(<span class="keyword">void</span>* thread)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSThread</span> *t = (<span class="built_in">NSThread</span>*)thread;</span><br><span class="line">    [nc postNotificationName: <span class="built_in">NSThreadDidStartNotification</span> object:t userInfo: <span class="literal">nil</span>];</span><br><span class="line">    [t _setName: [t name]];</span><br><span class="line">    [t main];</span><br><span class="line">    [<span class="built_in">NSThread</span> exit];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾问题发现，我们需要的是一个联系 NSThread 对象和内核 thread 的纽带，也就是说要找到 NSThread 对象的某个唯一值，而且内核 thread 也具有这个唯一值。</p>
<p>观察一下 NSThread，它的唯一值只有对象地址，对象序列号(Sequence Number) 和线程名称:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">NSThread</span>: <span class="number">0x144d095e0</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>地址分配在堆上，没有使用意义，序列号的计算没有看懂，因此只剩下 name。幸运的是 pthread 也提供了一个方法 <code>pthread_getname_np</code> 来获取线程的名字，两者是一致的，感兴趣的读者可以自行阅读 <code>setName</code> 方法的实现，它调用的就是 pthread 提供的接口。</p>
<p>这里的 <strong>np</strong> 表示 not POSIX，也就是说它并不能跨平台使用。</p>
<p>于是解决方案就很简单了，对于 NSThread 参数，把它的名字改为某个随机数(我选择了时间戳)，然后遍历 pthread 并检查有没有匹配的名字。查找完成后把参数的名字恢复即可。</p>
<h3 id="主线程转内核-thread"><a href="#主线程转内核-thread" class="headerlink" title="主线程转内核 thread"></a>主线程转内核 thread</h3><p>本来以为问题已经圆满解决，不料还有一个坑，主线程设置 name 后无法用 <code>pthread_getname_np</code> 读取到。</p>
<p>好在我们还可以迂回解决问题: 事先获得主线程的 <code>thread_t</code>，然后进行比对。</p>
<p>上述方案要求我们在主线程中执行代码从而获得 <code>thread_t</code>，显然最好的方案是在 load 方法里:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> mach_port_t main_thread_id;  </span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    main_thread_id = mach_thread_self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>OC的消息派发</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/OC%E7%9A%84%E6%B6%88%E6%81%AF%E6%B4%BE%E5%8F%91/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在之前，我们有说过，oc所有的方法调用最终都是转成objc_msgSend来发送消息。但是具体objc_msgSend里会做什么，还是需要窥探一番。但是在这里之前，有两个数据结构需要了解一下，包装了一个方法<strong><em>method_t</em></strong>，和<strong><em>cache_t</em></strong></p>
<h4 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a><em>method_t</em></h4><p><strong><em>method_t</em></strong>是包装方法的结构体，包含了方法的实现imp,签名selector，以及方法的type。对象所有的方法就是以一个个的<strong><em>method_t</em></strong>放在了对象所指的类的<strong><em>method_list_t</em></strong>的二维数组中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    IMP imp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SortBySELAddress</span> :</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;<span class="keyword">const</span> <span class="keyword">method_t</span>&amp;,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">method_t</span>&amp;, <span class="keyword">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">method_t</span>&amp; lhs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> <span class="keyword">method_t</span>&amp; rhs)</span></span></span><br><span class="line"><span class="function">        </span>&#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>SEL和IMP我们已经很熟悉了，但是这个types是什么呢，其实这里涉及到一个知识，iOS中提供了一个叫做@encode的指令，可以将具体的类型表示成字符串编码,通过这串编码表明了函数的返回值类型，参数类型以及所占字节数</p>
<h4 id="cache-t"><a href="#cache-t" class="headerlink" title="cache_t"></a><em>cache_t</em></h4><p>在消息派发中，很重要的一步就是查找缓存，所以还是有比较了解一下是怎么做的缓存比较重要。因为如果没有缓存，每次找到方法都需要在二维数组里查找，甚至要查找到父类的二维数组中去，这个开销是很大的。特别是在objc_msgSend调用这么频繁的情况下。所以正确的做法是只要调用过的函数，无论是父类的还是自己的，就保存到缓存中。每次先去缓存中取，如果没有再去做复杂的查找。首先我们看下<strong><em>cache_t</em></strong>的源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span> <span class="comment">// 散列表</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask; <span class="comment">// 散列表的长度-1,也代表着掩码</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied; <span class="comment">// 已缓存的方法个数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">cache_key_t</span> _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">cache_key_t</span> <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> IMP <span class="title">imp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (IMP)_imp; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(<span class="keyword">cache_key_t</span> newKey)</span> </span>&#123; _key = newKey; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setImp</span><span class="params">(IMP newImp)</span> </span>&#123; _imp = newImp; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">cache_key_t</span> newKey, IMP newImp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类对象结构体中有一个成员变量为<strong><em>cache_t</em></strong>的cache。这里装着所有当前类的调用过的方法的函数。其实正确的说法是cache_t中装着成员变量为bucket_t的散列表。而bucket_t里面就有函数的实现，并且这个key其实就是方法的签名SEL。</p>
<p>本质散列表就是一种以空间换取时间的数据结构，每次给cache_t一个起始的大小。然后当调用方法进行缓存时，就用函数的签名来和这个起始大小也就是_mask来做&amp;运算，得出的结果肯定是小于_mask的，这个结果就作为存在散列表中的索引，来存放这个方法的具体信息。取的时候也就直接通过方法的sel来与mask做&amp;拿到索引，然后直接取。</p>
<p>但是这个位运算的操作的结果有可能是相同的，所以底层在做存取的时候都是有做判断，例如存的时候先判空，如果空再存，否则往前移动。到最后如果移到头还是都不为空就会对散列表进行扩容。源码扩容是每次以原来的空间进行二倍扩容。并且扩容之后会对原来的数据清空。</p>
<p>而取的时候也是一样，取完会判断sel和自己的sel是不是对等，如果对等才说明取对了，否则继续前移。</p>
<p>经过整个处理，每次取方法实现的复杂度最优解可以变成<strong>O(1)</strong>，最复杂也只是<strong>O(n)</strong>而已，比之前要在二维数组以及父类的二维数组查找效率高太多了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::expand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> oldCapacity = capacity();</span><br><span class="line">    <span class="keyword">uint32_t</span> newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)(<span class="keyword">mask_t</span>)newCapacity != newCapacity) &#123;</span><br><span class="line">        <span class="comment">// mask overflow - can't grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="function"><span class="keyword">bucket_t</span> * <span class="title">cache_t::find</span><span class="params">(<span class="keyword">cache_key_t</span> k, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(k != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bucket_t</span> *b = buckets();</span><br><span class="line">    <span class="keyword">mask_t</span> m = mask();</span><br><span class="line">    <span class="keyword">mask_t</span> <span class="built_in">begin</span> = cache_hash(k, m);</span><br><span class="line">    <span class="keyword">mask_t</span> i = <span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i].key() == <span class="number">0</span>  ||  b[i].key() == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = cache_next(i, m)) != <span class="built_in">begin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    Class cls = (Class)((<span class="keyword">uintptr_t</span>)<span class="keyword">this</span> - offsetof(objc_class, cache));</span><br><span class="line">    <span class="keyword">cache_t</span>::bad_cache(receiver, (SEL)k, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cache_fill_nolock</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never cache before +initialize is done</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isInitialized()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the entry wasn't added to the cache by some other thread </span></span><br><span class="line">    <span class="comment">// before we grabbed the cacheUpdateLock.</span></span><br><span class="line">    <span class="keyword">if</span> (cache_getImp(cls, sel)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">cache_t</span> *cache = getCache(cls);</span><br><span class="line">    <span class="keyword">cache_key_t</span> key = <span class="built_in">getKey</span>(sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the cache as-is if it is less than 3/4 full</span></span><br><span class="line">    <span class="keyword">mask_t</span> newOccupied = cache-&gt;occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">mask_t</span> capacity = cache-&gt;capacity();</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        <span class="comment">// Cache is read-only. Replace it.</span></span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Cache is less than 3/4 full. Use it as-is.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Cache is too full. Expand it.</span></span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Scan for the first unused slot and insert there.</span></span><br><span class="line">    <span class="comment">// There is guaranteed to be an empty slot because the </span></span><br><span class="line">    <span class="comment">// minimum size is 4 and we resized at 3/4 full.</span></span><br><span class="line">    <span class="keyword">bucket_t</span> *bucket = cache-&gt;<span class="built_in">find</span>(key, receiver);</span><br><span class="line">  <span class="comment">// 如果当前找出来的bucket是空，就进行缓存，代表有空位</span></span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;key() == <span class="number">0</span>) cache-&gt;incrementOccupied();</span><br><span class="line">    bucket-&gt;<span class="built_in">set</span>(key, imp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-msgSend"><a href="#objc-msgSend" class="headerlink" title="objc_msgSend"></a><em>objc_msgSend</em></h4><p>没有什么比看源码更简单，直接通过关键字搜索，发现这部分的实现是用汇编实现的，其实这很好理解，需要高效率。但是基本的汇编还是能看懂</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">    ENTRY _objc_msgSend</span><br><span class="line">    UNWIND _objc_msgSend, NoFrame</span><br><span class="line">    MESSENGER_START</span><br><span class="line"></span><br><span class="line">// 判断<span class="keyword">x</span><span class="number">0</span>寄存器也就是消息接受者是否为空，如果是，直接跳转到LNilOrTagged，内部就是直接return</span><br><span class="line">    cmp    <span class="keyword">x</span><span class="number">0</span>, <span class="symbol">#0</span>            // nil check <span class="keyword">and</span> tagged pointer check</span><br><span class="line">    b.le    LNilOrTagged        //  (MSB tagged pointer looks negative)</span><br><span class="line">    ldr    <span class="keyword">x</span><span class="number">13</span>, [<span class="keyword">x</span><span class="number">0</span>]        // <span class="keyword">x</span><span class="number">13</span> = isa</span><br><span class="line">    <span class="keyword">and</span>    <span class="keyword">x</span><span class="number">16</span>, <span class="keyword">x</span><span class="number">13</span>, #ISA_MASK    // <span class="keyword">x</span><span class="number">16</span> = class    </span><br><span class="line">LGetIsaDone:</span><br><span class="line">  //如果不为空，就执行查找缓存 注释也写得很清楚，其实就是直接查找缓存调用imp，或者执行objc_msgSend_uncached</span><br><span class="line">    CacheLookup NORMAL        // calls imp <span class="keyword">or</span> objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">LNilOrTagged:</span><br><span class="line">    b.<span class="keyword">eq</span>    LReturnZero        // nil check</span><br><span class="line"></span><br><span class="line">    // tagged</span><br><span class="line">    mov    <span class="keyword">x</span><span class="number">10</span>, <span class="symbol">#0</span>xf<span class="number">000000000000000</span></span><br><span class="line">    cmp    <span class="keyword">x</span><span class="number">0</span>, <span class="keyword">x</span><span class="number">10</span></span><br><span class="line">    b.hs    LExtTag</span><br><span class="line">    adrp    <span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_classes<span class="title">@PAGE</span></span><br><span class="line">    <span class="keyword">add</span>    <span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_classes<span class="title">@PAGEOFF</span></span><br><span class="line">    ubfx    <span class="keyword">x</span><span class="number">11</span>, <span class="keyword">x</span><span class="number">0</span>, <span class="symbol">#60</span>, <span class="symbol">#4</span></span><br><span class="line">    ldr    <span class="keyword">x</span><span class="number">16</span>, [<span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">11</span>, LSL <span class="symbol">#3</span>]</span><br><span class="line">    b    LGetIsaDone</span><br><span class="line"></span><br><span class="line">LExtTag:</span><br><span class="line">    // ext tagged</span><br><span class="line">    adrp    <span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_ext_classes<span class="title">@PAGE</span></span><br><span class="line">    <span class="keyword">add</span>    <span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">10</span>, _objc_debug_taggedpointer_ext_classes<span class="title">@PAGEOFF</span></span><br><span class="line">    ubfx    <span class="keyword">x</span><span class="number">11</span>, <span class="keyword">x</span><span class="number">0</span>, <span class="symbol">#52</span>, <span class="symbol">#8</span></span><br><span class="line">    ldr    <span class="keyword">x</span><span class="number">16</span>, [<span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">11</span>, LSL <span class="symbol">#3</span>]</span><br><span class="line">    b    LGetIsaDone</span><br><span class="line">    </span><br><span class="line">LReturnZero:</span><br><span class="line">    // <span class="keyword">x</span><span class="number">0</span> is already zero</span><br><span class="line">    mov    <span class="keyword">x</span><span class="number">1</span>, <span class="symbol">#0</span></span><br><span class="line">    movi    d<span class="number">0</span>, <span class="symbol">#0</span></span><br><span class="line">    movi    d<span class="number">1</span>, <span class="symbol">#0</span></span><br><span class="line">    movi    d<span class="number">2</span>, <span class="symbol">#0</span></span><br><span class="line">    movi    d<span class="number">3</span>, <span class="symbol">#0</span></span><br><span class="line">    MESSENGER_END_NIL</span><br><span class="line">    <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">    END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure>

<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">// 查找缓存</span><br><span class="line">.macro CacheLookup</span><br><span class="line">    // <span class="keyword">x</span><span class="number">1</span> = SEL, <span class="keyword">x</span><span class="number">16</span> = isa</span><br><span class="line">    ldp    <span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">11</span>, [<span class="keyword">x</span><span class="number">16</span>, #CACHE]    // <span class="keyword">x</span><span class="number">10</span> = buckets, <span class="keyword">x</span><span class="number">11</span> = occupied|mask</span><br><span class="line">    <span class="keyword">and</span>    w<span class="number">12</span>, w<span class="number">1</span>, w<span class="number">11</span>        // <span class="keyword">x</span><span class="number">12</span> = _cmd &amp; mask</span><br><span class="line">    <span class="keyword">add</span>    <span class="keyword">x</span><span class="number">12</span>, <span class="keyword">x</span><span class="number">10</span>, <span class="keyword">x</span><span class="number">12</span>, LSL <span class="symbol">#4</span>    // <span class="keyword">x</span><span class="number">12</span> = buckets + ((_cmd &amp; mask)&lt;&lt;<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    ldp    <span class="keyword">x</span><span class="number">9</span>, <span class="keyword">x</span><span class="number">17</span>, [<span class="keyword">x</span><span class="number">12</span>]        // &#123;<span class="keyword">x</span><span class="number">9</span>, <span class="keyword">x</span><span class="number">17</span>&#125; = *bucket</span><br><span class="line"><span class="number">1</span>:    cmp    <span class="keyword">x</span><span class="number">9</span>, <span class="keyword">x</span><span class="number">1</span>            // if (bucket-&gt;sel != _cmd)</span><br><span class="line">    b.<span class="keyword">ne</span>    <span class="number">2</span>f            //     scan more</span><br><span class="line">    CacheHit $<span class="number">0</span>            // <span class="keyword">call</span> <span class="keyword">or</span> return imp</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>:    // not hit: <span class="keyword">x</span><span class="number">12</span> = not-hit bucket</span><br><span class="line">    CheckMiss $<span class="number">0</span>            // miss if bucket-&gt;sel == <span class="number">0</span></span><br><span class="line">    cmp    <span class="keyword">x</span><span class="number">12</span>, <span class="keyword">x</span><span class="number">10</span>        // wrap if bucket == buckets</span><br><span class="line">    b.<span class="keyword">eq</span>    <span class="number">3</span>f</span><br><span class="line">    ldp    <span class="keyword">x</span><span class="number">9</span>, <span class="keyword">x</span><span class="number">17</span>, [<span class="keyword">x</span><span class="number">12</span>, #<span class="number">-16</span>]!    // &#123;<span class="keyword">x</span><span class="number">9</span>, <span class="keyword">x</span><span class="number">17</span>&#125; = *--bucket</span><br><span class="line">    b    <span class="number">1</span>b            // loop</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:    // wrap: <span class="keyword">x</span><span class="number">12</span> = first bucket, w<span class="number">11</span> = mask</span><br><span class="line">    <span class="keyword">add</span>    <span class="keyword">x</span><span class="number">12</span>, <span class="keyword">x</span><span class="number">12</span>, w<span class="number">11</span>, UXTW <span class="symbol">#4</span>    // <span class="keyword">x</span><span class="number">12</span> = buckets+(mask&lt;&lt;<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    // Clone scanning loop <span class="keyword">to</span> miss instead of hang when cache is corrupt.</span><br><span class="line">    // The slow path may detect any corruption <span class="keyword">and</span> halt later.</span><br><span class="line"></span><br><span class="line">    ldp    <span class="keyword">x</span><span class="number">9</span>, <span class="keyword">x</span><span class="number">17</span>, [<span class="keyword">x</span><span class="number">12</span>]        // &#123;<span class="keyword">x</span><span class="number">9</span>, <span class="keyword">x</span><span class="number">17</span>&#125; = *bucket</span><br><span class="line"><span class="number">1</span>:    cmp    <span class="keyword">x</span><span class="number">9</span>, <span class="keyword">x</span><span class="number">1</span>            // if (bucket-&gt;sel != _cmd)</span><br><span class="line">    b.<span class="keyword">ne</span>    <span class="number">2</span>f            //     scan more</span><br><span class="line">    CacheHit $<span class="number">0</span>            // <span class="keyword">call</span> <span class="keyword">or</span> return imp</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span>:    // not hit: <span class="keyword">x</span><span class="number">12</span> = not-hit bucket</span><br><span class="line">    CheckMiss $<span class="number">0</span>            // miss if bucket-&gt;sel == <span class="number">0</span></span><br><span class="line">    cmp    <span class="keyword">x</span><span class="number">12</span>, <span class="keyword">x</span><span class="number">10</span>        // wrap if bucket == buckets</span><br><span class="line">    b.<span class="keyword">eq</span>    <span class="number">3</span>f</span><br><span class="line">    ldp    <span class="keyword">x</span><span class="number">9</span>, <span class="keyword">x</span><span class="number">17</span>, [<span class="keyword">x</span><span class="number">12</span>, #<span class="number">-16</span>]!    // &#123;<span class="keyword">x</span><span class="number">9</span>, <span class="keyword">x</span><span class="number">17</span>&#125; = *--bucket</span><br><span class="line">    b    <span class="number">1</span>b            // loop</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:    // <span class="keyword">double</span> wrap</span><br><span class="line">    JumpMiss $<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>后面一系列查找很多，最终会找到一个c函数<em>__class_lookupMethodAndLoadCache3</em>，这个方法很长，直接看注释就行了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* lookUpImpOrForward.</span></span><br><span class="line"><span class="comment">* The standard IMP lookup. </span></span><br><span class="line"><span class="comment">* initialize==NO tries to avoid +initialize (but sometimes fails)</span></span><br><span class="line"><span class="comment">* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)</span></span><br><span class="line"><span class="comment">* Most callers should use initialize==YES and cache==YES.</span></span><br><span class="line"><span class="comment">* inst is an instance of cls or a subclass thereof, or nil if none is known. </span></span><br><span class="line"><span class="comment">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span></span><br><span class="line"><span class="comment">* May return _objc_msgForward_impcache. IMPs destined for external use </span></span><br><span class="line"><span class="comment">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span></span><br><span class="line"><span class="comment">*   If you don't want forwarding at all, use lookUpImpOrNil() instead.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试在缓存中找</span></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during isRealized and isInitialized checking</span></span><br><span class="line">    <span class="comment">// to prevent races against concurrent realization.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runtimeLock is held during method search to make</span></span><br><span class="line">    <span class="comment">// method-lookup + cache-fill atomic with respect to method addition.</span></span><br><span class="line">    <span class="comment">// Otherwise, a category could be added but ignored indefinitely because</span></span><br><span class="line">    <span class="comment">// the cache was re-filled with the old value after the cache flush on</span></span><br><span class="line">    <span class="comment">// behalf of the category.</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        <span class="comment">// Drop the read-lock and acquire the write-lock.</span></span><br><span class="line">        <span class="comment">// realizeClass() checks isRealized() again to prevent</span></span><br><span class="line">        <span class="comment">// a race while the lock is down.</span></span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        runtimeLock.<span class="built_in">write</span>();</span><br><span class="line"></span><br><span class="line">        realizeClass(cls);</span><br><span class="line"></span><br><span class="line">        runtimeLock.unlockWrite();</span><br><span class="line">        runtimeLock.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        runtimeLock.<span class="built_in">read</span>();</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"> retry:    </span><br><span class="line">    runtimeLock.assertReading();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's cache.</span></span><br><span class="line"></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's method lists.</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方法列表查找(折半查找)</span></span><br><span class="line">        Method meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            <span class="comment">// 找到去缓存到自己的cache中</span></span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归往父类的方法列表查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> attempts = unreasonableClassCount();</span><br><span class="line">        <span class="keyword">for</span> (Class curClass = cls-&gt;superclass;</span><br><span class="line">             curClass != nil;</span><br><span class="line">             curClass = curClass-&gt;superclass)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Halt if there is a cycle in the superclass chain.</span></span><br><span class="line">            <span class="keyword">if</span> (--attempts == <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"Memory corruption in class list."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass cache.</span></span><br><span class="line">            imp = cache_getImp(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">                <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                    <span class="comment">// Found the method in a superclass. Cache it in this class.(在父类中找到，缓存到自己类的cache)</span></span><br><span class="line">                    log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                    <span class="keyword">goto</span> done;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                    <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                    <span class="comment">// resolver for this class first.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Superclass method list.</span></span><br><span class="line">            Method meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">            <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">                log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">                imp = meth-&gt;imp;</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态解析</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        runtimeLock.<span class="built_in">read</span>();</span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 消息转发</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实很大一部分都是在查找方法列表并且进行缓存的阶段。我们可以把这部分叫做消息发送阶段。消息发送阶段我们可以用这张图来解释</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/OC%E7%9A%84%E6%B6%88%E6%81%AF%E6%B4%BE%E5%8F%91/OC%E7%9A%84%E6%B6%88%E6%81%AF%E6%B4%BE%E5%8F%911.png" alt="OC的消息派发"></p>
<p>然后在最后没有找到会进行动态解析阶段。动态解析阶段再失败进入消息转发阶段</p>
<h4 id="动态解析"><a href="#动态解析" class="headerlink" title="动态解析"></a>动态解析</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _class_resolveMethod</span></span><br><span class="line"><span class="comment">* Call +resolveClassMethod or +resolveInstanceMethod.</span></span><br><span class="line"><span class="comment">* Returns nothing; any result would be potentially out-of-date already.</span></span><br><span class="line"><span class="comment">* Does not check if the method already exists.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, id inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实看注释就说明了，如果找不到方法，进入这个消息动态解析方法，会通过是类对象还是元类对象来调用对应的resolveClassMethod方法来进行补救</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/OC%E7%9A%84%E6%B6%88%E6%81%AF%E6%B4%BE%E5%8F%91/OC%E7%9A%84%E6%B6%88%E6%81%AF%E6%B4%BE%E5%8F%912.png" alt="OC的消息派发"></p>
<h4 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h4><p>在消息发送阶段没有查找到方法之后，会进入动态解析。如果发现动态解析也失败，就代表这个类没有能力处理这个方法。所以会进入消息转发阶段。看看其他类是否有能力替当前类处理消息。在上面我们有看到消息转发执行的是__objc_msgForward_impcache。这个函数的实现也是由汇编实现的</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">STATIC_ENTRY <span class="variable">__objc_msgForward_impcache</span></span><br><span class="line"><span class="comment">// Method cache version</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// THIS IS NOT A CALLABLE C FUNCTION</span></span><br><span class="line"><span class="comment">// Out-of-band Z is 0 (EQ) for normal, 1 (NE) for stret</span></span><br><span class="line"></span><br><span class="line">MESSENGER_START</span><br><span class="line">nop</span><br><span class="line">MESSENGER_END_SLOW</span><br><span class="line"></span><br><span class="line">beq    <span class="variable">__objc_msgForward</span></span><br><span class="line">b    <span class="variable">__objc_msgForward_stret</span></span><br><span class="line"></span><br><span class="line">END_ENTRY <span class="variable">__objc_msgForward_impcache</span></span><br></pre></td></tr></table></figure>

<p>可以看到里面调用了__objc_msgForward，但是这个是corefoudation的，但是闭源了。但是网上有大神通过静态分析汇编生成了一份伪代码。其实大概实现就是这样</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/OC%E7%9A%84%E6%B6%88%E6%81%AF%E6%B4%BE%E5%8F%91/OC%E7%9A%84%E6%B6%88%E6%81%AF%E6%B4%BE%E5%8F%913.png" alt="OC的消息派发"></p>
<p>这里的方法签名说的就是上面的typeEcode。也可以看到到最后也没处理的话就会调用doesNotRecognizeSelector:，这里就是抛异常，crash了</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>其实整体objc_msgSend就是3个阶段，消息发送-&gt;动态解析-&gt;消息转发。其中消息发送就就可以理解为方法的查找和缓存。</p>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>RSA原理</title>
    <url>/%E7%AE%97%E6%B3%95/RSA%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p><em>1976年之前用的用的都是对称加密</em></p>
<blockquote>
<p>（1）甲方选择某一种加密规则，对信息进行加密；</p>
<p>（2）乙方使用同一种规则，对信息进行解密。</p>
</blockquote>
<p><em>1976年，两位美国计算机学家Whitfield Diffie 和 Martin Hellman，提出了一种崭新构思，可以在不直接传递密钥的情况下，完成解密。这被称为<a href="http://en.wikipedia.org/wiki/Diffie–Hellman_key_exchange" target="_blank" rel="noopener">“Diffie-Hellman密钥交换算法”</a>。这个算法启发了其他科学家。人们认识到，加密和解密可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，这样就避免了直接传递密钥</em></p>
<p><em>如果公钥加密的信息只有私钥解得开，那么只要私钥不泄漏，通信就是安全的。</em></p>
<blockquote>
<p>（1）乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。</p>
<p>（2）甲方获取乙方的公钥，然后用它对信息加密。</p>
<p>（3）乙方得到加密后的信息，用私钥解密。</p>
</blockquote>
<p>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做<a href="http://zh.wikipedia.org/zh-cn/RSA加密算法" target="_blank" rel="noopener">RSA算法</a>。从那时直到现在，RSA算法一直是最广为使用的”非对称加密算法”。毫不夸张地说，只要有计算机网络的地方，就有RSA算法。</p>
<p>这种算法非常<a href="http://en.wikipedia.org/wiki/RSA_Factoring_Challenge" target="_blank" rel="noopener">可靠</a>，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。(归根结底是因为破解RSA需要求)</p>
<p>下面，我就进入正题，解释RSA算法的原理。文章共分成两部分，今天是第一部分，介绍要用到的四个数学概念。你可以看到，RSA算法并不难，只需要一点<a href="http://jeremykun.com/2011/07/30/number-theory-a-primer/" target="_blank" rel="noopener">数论知识</a>就可以理解。</p>
<h3 id="互质关系"><a href="#互质关系" class="headerlink" title="互质关系"></a>互质关系</h3><p><em>质数</em>是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。</p>
<p>*如果两个正整数，除了1以外，没有其他公因子，我们就称这两个数是<a href="http://zh.wikipedia.org/zh-cn/互素" target="_blank" rel="noopener">互质关系</a>（coprime）。比如，15和32没有公因子，所以它们是互质关系。这说明，不是质数也可以构成互质关系。</p>
<p>关于互质关系，不难得到以下结论：</p>
<blockquote>
<ol>
<li><p>任意两个质数构成互质关系，比如13和61。</p>
</li>
<li><p>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。</p>
</li>
<li><p>如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。</p>
</li>
<li><p>1和任意一个自然数是都是互质关系，比如1和99。</p>
</li>
<li><p>p是大于1的整数，则p和p-1构成互质关系，比如57和56。</p>
</li>
<li><p>p是大于1的奇数，则p和p-2构成互质关系，比如17和15。</p>
</li>
</ol>
</blockquote>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><blockquote>
<p>任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）</p>
</blockquote>
<p>计算这个值的方法就叫<em>欧拉函数<em>，以<u></u></em>φ(n)</em>表示，在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。φ(n) 的计算方法并不复杂，但是为了得到最后那个公式，需要一步步讨论。</p>
<p>第一种情况</p>
<p>如果n=1，则 φ(1) = 1 。因为1与任何数（包括自身）都构成互质关系。</p>
<p>第二种情况</p>
<p>如果n是质数，则 φ(n)=n-1 。因为质数与小于它的每一个数，都构成互质关系。比如5与1、2、3、4都构成互质关系。</p>
<p>第三种情况</p>
<p>如果n是质数的某一个次方，即 n = p^k (p为质数，k为大于等于1的整数)，则</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c0573f4a25a.png" alt="2015-08-04/55c0573f4a25a"></p>
<p>比如 φ(8) = φ(2^3) =2^3 - 2^2 = 8 -4 = 4。</p>
<p>这是因为只有当一个数不包含质数p，才可能与n互质。而包含质数p的数一共有p^(k-1)个，即1×p、2×p、3×p、…、p^(k-1)×p，把它们去除，剩下的就是与n互质的数。</p>
<p>上面的式子还可以写成下面的形式：</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c0578076585.png" alt="2015-08-04/55c0578076585"></p>
<p>可以看出，上面的第二种情况是 k=1 时的特例。</p>
<p>第四种情况</p>
<p>如果n可以分解成两个互质的整数之积，</p>
<blockquote>
<p>n = p1 × p2</p>
</blockquote>
<p>则</p>
<blockquote>
<p>φ(n) = φ(p1p2) = φ(p1)φ(p2)</p>
</blockquote>
<p>即积的欧拉函数等于各个因子的欧拉函数之积。比如，φ(56)=φ(8×7)=φ(8)×φ(7)=4×6=24。</p>
<p>这一条的证明要用到<a href="http://en.wikipedia.org/wiki/Chinese_remainder_theorem" target="_blank" rel="noopener">“中国剩余定理”</a>，这里就不展开了，只简单说一下思路：如果a与p1互质(a&lt;p1)，b与p2互质(b&lt;p2)，c与p1p2互质(c&lt;p1p2)，则c与数对 (a,b) 是一一对应关系。由于a的值有φ(p1)种可能，b的值有φ(p2)种可能，则数对 (a,b) 有φ(p1)φ(p2)种可能，而c的值有φ(p1p2)种可能，所以φ(p1p2)就等于φ(p1)φ(p2)。</p>
<p>第五种情况</p>
<p>因为任意一个大于1的正整数，都可以写成一系列质数的积。<br><img src="https://box.kancloud.cn/2015-08-04_55c057f99f735.png" alt="2015-08-04/55c057f99f735"></p>
<p>根据第4条的结论，得到<br><img src="https://box.kancloud.cn/2015-08-04_55c05835ca6e2.png" alt="2015-08-04/55c05835ca6e2"></p>
<p>再根据第3条的结论，得到</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c05871f2594.png" alt="2015-08-04/55c05871f2594"></p>
<p>也就等于</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c058b16129e.png" alt="2015-08-04/55c058b16129e"></p>
<p>这就是欧拉函数的通用计算公式。比如，1323的欧拉函数，计算过程如下：</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c059446c936.png" alt="2015-08-04/55c059446c936"></p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>欧拉函数的用处，在于[欧拉定理]。”欧拉定理”指的是：</p>
<blockquote>
<p>如果两个正整数a和n互质，则n的欧拉函数 φ(n) 可以让下面的等式成立：</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c059520a3e8.png" alt="2015-08-04/55c059520a3e8"></p>
</blockquote>
<p>也就是说，a的φ(n)次方被n除的余数为1。或者说，a的φ(n)次方减去1，可以被n整除。比如，3和7互质，而7的欧拉函数φ(7)等于6，所以3的6次方（729）减去1，可以被7整除（728/7=104）。</p>
<p>欧拉定理的证明比较复杂，这里就省略了。我们只要记住它的结论就行了。</p>
<p>欧拉定理可以大大简化某些运算。比如，7和10互质，根据欧拉定理，</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c05962e83e9.png" alt="2015-08-04/55c05962e83e9"></p>
<p>已知 φ(10) 等于4，所以马上得到7的4倍数次方的个位数肯定是1。</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c0596cb6dd4.png" alt="2015-08-04/55c0596cb6dd4"></p>
<p>因此，7的任意次方的个位数（例如7的222次方），心算就可以算出来。</p>
<p>欧拉定理有一个特殊情况。</p>
<blockquote>
<p>假设正整数a与质数p互质，因为质数p的φ(p)等于p-1，则欧拉定理可以写成</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c0597866ff0.png" alt="2015-08-04/55c0597866ff0"></p>
</blockquote>
<p>这就是著名的<a href="http://zh.wikipedia.org/wiki/费马小定理" target="_blank" rel="noopener">费马小定理</a>。它是欧拉定理的特例。</p>
<p>欧拉定理是RSA算法的核心。理解了这个定理，就可以理解RSA。</p>
<h3 id="模反元素"><a href="#模反元素" class="headerlink" title="模反元素"></a>模反元素</h3><blockquote>
<p>如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c059871365d.png" alt="2015-08-04/55c059871365d"></p>
<p>这时，b就叫做a的<a href="http://zh.wikipedia.org/wiki/模反元素" target="_blank" rel="noopener">“模反元素”</a>。</p>
</blockquote>
<p>比如，3和11互质，那么3的模反元素就是4，因为 (3 × 4)-1 可以被11整除。显然，模反元素不止一个， 4加减11的整数倍都是3的模反元素 {…,-18,-7,4,15,26,…}，即如果b是a的模反元素，则 b+kn 都是a的模反元素。</p>
<p>欧拉定理可以用来证明模反元素必然存在。</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c059984b9aa.png" alt="2015-08-04/55c059984b9aa"></p>
<p>可以看到，a的 φ(n)-1 次方，就是a的模反元素。</p>
<h3 id="密钥生成的步骤"><a href="#密钥生成的步骤" class="headerlink" title="密钥生成的步骤"></a>密钥生成的步骤</h3><p>前面我介绍了一些数论知识。<br>有了这些知识，我们就可以看懂RSA算法。这是目前地球上最重要的加密算法。</p>
<p>我们通过一个例子，来理解RSA算法。假设<a href="http://zh.wikipedia.org/wiki/爱丽丝与鲍伯" target="_blank" rel="noopener">爱丽丝</a>要与鲍勃进行加密通信，她该怎么生成公钥和私钥呢？</p>
<p><img src="https://box.kancloud.cn/2015-08-04_55c05a8911a90.png" alt="img"></p>
<p>第一步，随机选择两个不相等的质数p和q。</p>
<p>爱丽丝选择了61和53。（实际应用中，这两个质数越大，就越难破解。）</p>
<p>第二步，计算p和q的乘积n。</p>
<p>爱丽丝就把61和53相乘。</p>
<blockquote>
<p>n = 61×53 = 3233</p>
</blockquote>
<p>n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。实际应用中，RSA密钥一般是1024位，重要场合则为2048位。</p>
<p>第三步，计算n的欧拉函数φ(n)。</p>
<p>根据公式：</p>
<blockquote>
<p>φ(n) = (p-1)(q-1)</p>
</blockquote>
<p>爱丽丝算出φ(3233)等于60×52，即3120。</p>
<p>第四步，随机选择一个整数e，条件是1</p>
<p>爱丽丝就在1到3120之间，随机选择了17。（实际应用中，常常选择65537。）</p>
<p>第五步，计算e对于φ(n)的模反元素d。</p>
<p>所谓<a href="http://zh.wikipedia.org/wiki/模反元素" target="_blank" rel="noopener">“模反元素”</a>就是指有一个整数d，可以使得ed被φ(n)除的余数为1。</p>
<blockquote>
<p>ed ≡ 1 (mod φ(n))</p>
</blockquote>
<p>这个式子等价于</p>
<blockquote>
<p>ed - 1 = kφ(n)</p>
</blockquote>
<p>于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。</p>
<blockquote>
<p>ex + φ(n)y = 1</p>
</blockquote>
<p>已知 e=17, φ(n)=3120，</p>
<blockquote>
<p>17x + 3120y = 1</p>
</blockquote>
<p>这个方程可以用<a href="http://zh.wikipedia.org/wiki/扩展欧几里得算法" target="_blank" rel="noopener">“扩展欧几里得算法”</a>求解，此处省略具体过程。总之，爱丽丝算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。</p>
<p>至此所有计算完成。</p>
<p>第六步，将n和e封装成公钥，n和d封装成私钥。</p>
<p>在爱丽丝的例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。</p>
<p>实际应用中，公钥和私钥的数据都采用<a href="http://zh.wikipedia.org/zh-cn/ASN.1" target="_blank" rel="noopener">ASN.1</a>格式表达（<a href="http://hi.baidu.com/mathack/item/d0ad4cc1514a3663f7c95da2" target="_blank" rel="noopener">实例</a>）。</p>
<h3 id="RSA的可靠性以及破解"><a href="#RSA的可靠性以及破解" class="headerlink" title="RSA的可靠性以及破解"></a>RSA的可靠性以及破解</h3><p>回顾上面的密钥生成步骤，一共出现六个数字：</p>
<blockquote>
<p>p<br>　　q<br>　　n<br>　　φ(n)<br>　　e<br>　　d</p>
</blockquote>
<p>这六个数字之中，公钥用到了两个（n和e），其余四个数字都是不公开的。其中最关键的是d，因为n和d组成了私钥，一旦d泄漏，就等于私钥泄漏。</p>
<p>那么，有无可能在已知n和e的情况下，推导出d？</p>
<blockquote>
<p>（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。</p>
<p>（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。</p>
<p>（3）n=pq。只有将n因数分解，才能算出p和q。</p>
</blockquote>
<p>结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。</p>
<p>可是，大整数的因数分解，是一件非常困难的事情。目前，除了暴力破解，还没有发现别的有效方法。维基百科这样写道：</p>
<blockquote>
<p>“对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。</p>
<p>假如有人找到一种快速因数分解的算法，那么RSA的可靠性就会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA密钥才可能被暴力破解。到2008年为止，世界上还没有任何可靠的攻击RSA算法的方式。</p>
<p>只要密钥长度足够长，用RSA加密的信息实际上是不能被解破的。”</p>
</blockquote>
<p>举例来说，你可以对3233进行因数分解（61×53），但是你没法对下面这个整数进行因数分解。</p>
<blockquote>
<p>​       12301866845301177551304949<br>　　58384962720772853569595334<br>　　79219732245215172640050726<br>　　36575187452021997864693899<br>　　56474942774063845925192557<br>　　32630345373154826850791702<br>　　61221429134616704292143116<br>　　02221240479274737794080665<br>　　351419597459856902143413</p>
</blockquote>
<p>它等于这样两个质数的乘积：</p>
<blockquote>
<p>​       33478071698956898786044169<br>　　84821269081770479498371376<br>　　85689124313889828837938780<br>　　02287614711652531743087737<br>　　814467999489<br>　　　　×<br>　　36746043666799590428244633<br>　　79962795263227915816434308<br>　　76426760322838157396665112<br>　　79233373417143396810270092<br>　　798736308917</p>
</blockquote>
<p>事实上，这大概是人类已经分解的最大整数（232个十进制位，768个二进制位）。比它更大的因数分解，还没有被报道过，因此目前被破解的最长RSA密钥就是768位。</p>
<h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h3><p>有了公钥和密钥，就能进行加密和解密了。</p>
<p>（1）加密要用公钥 (n,e)</p>
<p>假设鲍勃要向爱丽丝发送加密信息m，他就要用爱丽丝的公钥 (n,e) 对m进行加密。这里需要注意，m必须是整数（字符串可以取ascii值或unicode值），且m必须小于n。</p>
<p>所谓”加密”，就是算出下式的c：</p>
<blockquote>
<p>me ≡ c (mod n)</p>
</blockquote>
<p>爱丽丝的公钥是 (3233, 17)，鲍勃的m假设是65，那么可以算出下面的等式：</p>
<blockquote>
<p>6517 ≡ 2790 (mod 3233)</p>
</blockquote>
<p>于是，c等于2790，鲍勃就把2790发给了爱丽丝。</p>
<p>（2）解密要用私钥(n,d)</p>
<p>爱丽丝拿到鲍勃发来的2790以后，就用自己的私钥(3233, 2753) 进行解密。可以证明，下面的等式一定成立：</p>
<blockquote>
<p>cd ≡ m (mod n)</p>
</blockquote>
<p>也就是说，c的d次方除以n的余数为m。现在，c等于2790，私钥是(3233, 2753)，那么，爱丽丝算出</p>
<blockquote>
<p>27902753 ≡ 65 (mod 3233)</p>
</blockquote>
<p>因此，爱丽丝知道了鲍勃加密前的原文就是65。</p>
<p>至此，”加密–解密”的整个过程全部完成。</p>
<p>我们可以看到，如果不知道d，就没有办法从c求出m。而前面已经说过，要知道d就必须分解n，这是极难做到的，所以RSA算法保证了通信安全。</p>
<p>你可能会问，公钥(n,e) 只能加密小于n的整数m，那么如果要加密大于n的整数，该怎么办？有两种解决方法：一种是把长信息分割成若干段短消息，每段分别加密；另一种是先选择一种”对称性加密算法”（比如<a href="https://zh.wikipedia.org/wiki/资料加密标准" target="_blank" rel="noopener">DES</a>），用这种算法的密钥加密信息，再用RSA公钥加密DES密钥。</p>
<p>但是RSA比较慢，rsa慢在他以幂模运算为基础，也就是c^e mod N。</p>
<h3 id="解密和加密的证明"><a href="#解密和加密的证明" class="headerlink" title="解密和加密的证明"></a>解密和加密的证明</h3><p>最后，我们来证明，为什么用私钥解密，一定可以正确地得到m。也就是证明下面这个式子：</p>
<blockquote>
<p>cd ≡ m (mod n)</p>
</blockquote>
<p>因为，根据加密规则</p>
<blockquote>
<p>ｍe ≡ c (mod n)</p>
</blockquote>
<p>于是，c可以写成下面的形式：</p>
<blockquote>
<p>c = me - kn</p>
</blockquote>
<p>将c代入要我们要证明的那个解密规则：</p>
<blockquote>
<p>(me - kn)d ≡ m (mod n)</p>
</blockquote>
<p>它等同于求证</p>
<blockquote>
<p>med ≡ m (mod n)</p>
</blockquote>
<p>由于</p>
<blockquote>
<p>ed ≡ 1 (mod φ(n))</p>
</blockquote>
<p>所以</p>
<blockquote>
<p>ed = hφ(n)+1</p>
</blockquote>
<p>将ed代入：</p>
<blockquote>
<p>mhφ(n)+1 ≡ m (mod n)</p>
</blockquote>
<p>接下来，分成两种情况证明上面这个式子。</p>
<p>（1）m与n互质。</p>
<p>根据欧拉定理，此时</p>
<blockquote>
<p>mφ(n) ≡ 1 (mod n)</p>
</blockquote>
<p>得到</p>
<blockquote>
<p>(mφ(n))h × m ≡ m (mod n)</p>
</blockquote>
<p>原式得到证明。</p>
<p>（2）m与n不是互质关系。</p>
<p>此时，由于n等于质数p和q的乘积，所以m必然等于kp或kq。</p>
<p>以 m = kp为例，考虑到这时k与q必然互质，则根据欧拉定理，下面的式子成立：</p>
<blockquote>
<p>(kp)q-1 ≡ 1 (mod q)</p>
</blockquote>
<p>进一步得到</p>
<blockquote>
<p>[(kp)q-1]h(p-1) × kp ≡ kp (mod q)</p>
</blockquote>
<p>即</p>
<blockquote>
<p>(kp)ed ≡ kp (mod q)</p>
</blockquote>
<p>将它改写成下面的等式</p>
<blockquote>
<p>(kp)ed = tq + kp</p>
</blockquote>
<p>这时t必然能被p整除，即 t=t’p</p>
<blockquote>
<p>(kp)ed = t’pq + kp</p>
</blockquote>
<p>因为 m=kp，n=pq，所以</p>
<blockquote>
<p>med ≡ m (mod n)</p>
</blockquote>
<p>原式得到证明。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>SwiftUI初体验</title>
    <url>/swift/SwiftUI%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h3 id="自我代码风格的历程"><a href="#自我代码风格的历程" class="headerlink" title="自我代码风格的历程"></a>自我代码风格的历程</h3><h6 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h6><p>​    从刚学iOS时的代码毫无架构，到了解了MVC，原来知道代码可以这么写。到业务量增大，C中代码太多了，转变成了一个单纯把C代码移动ViewModel中，给C减负，单纯把文件1拆为2不怎么样的伪MVVM。再到后来接触到swift，以及<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">FRP</a>用到的MVVM+<a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="noopener">RxSwift</a>，觉得写起来特别舒服。当时就觉得移动端就应该是这样的，拿到数据，展示，做一些动画和UI的处理。没有updateUI的代码,用户的操作改变了视图数据，自动刷新UI。不得不说，当时写完的代码自己看起来都觉得一目了然，特别舒服，连注释都不用写太多</p>
<h6 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h6><p>​    <a href="https://developer.apple.com/videos/wwdc2019" target="_blank" rel="noopener"><strong>WWDC2019</strong></a>让我记忆犹新，苹果推出了2个框架<a href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener">SwiftUI</a>,和<a href="https://developer.apple.com/documentation/combine" target="_blank" rel="noopener">Combine</a>,分别说说这两个东西</p>
<blockquote>
<ol>
<li><a href="https://developer.apple.com/documentation/combine" target="_blank" rel="noopener">Combine</a> 简单来说，这就是苹果自己的一个swift上的<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">FRP</a>框架，这不是苹果第一次把第三方的东西自己拿来实现了，例如之前很多的Xcode的插件，都被苹果自己实现了。看到这个消息是很开心的，因为对于国内开发者来说，swift都比较少。rxswift可以说是异类中的异类，不被接受。<a href="https://developer.apple.com/documentation/combine" target="_blank" rel="noopener">Combine</a> 的出现，起码说明了苹果接下来要对这方面的大力推广以及肯定。这点在<a href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener">SwiftUI</a>中，得到了认证</li>
<li><a href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener">SwiftUI</a>  搬运一段官网的话。”SwiftUI is an innovative, exceptionally <strong>simple way</strong> to build user interfaces <strong>across all Apple platforms</strong> with the power of Swift. Build user interfaces for any Apple device using just one set of tools and APIs. With a <strong>declarative Swift syntax</strong> that’s easy to read and natural to write, SwiftUI works seamlessly with new Xcode design tools to keep your code and design perfectly in sync“ 概括来说，开发简单，跨平台,并且与以往命令式UI不同，采用了声明式UI的开发方式。具体后面再继续说</li>
</ol>
</blockquote>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC</a></h2><p>刚入门的时候写OC常用的写法，非常感谢自己当时入门看到的一个教程<a href="https://medium.com/@seabjackson/cs193p-developing-ios-11-apps-with-swift-lecture-2-notes-bad3318aedde" target="_blank" rel="noopener">CS193P</a>，让我在理解<a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC</a>的时候特别的深刻，在后续找工作中因为在这方面的理解也脱颖而出.BTW,<a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC</a>其实就是一种对代码进行结构分层的方法，毕竟把所有的类放在一个文件这并不优雅。接下来引用一下教程中的的图片来理解。</p>
<p><img src="/swift/SwiftUI%E5%88%9D%E4%BD%93%E9%AA%8C/mvc.png" alt="mvc"></p>
<p>上图中代表了3个模块之间的交互方式，不过在这之前，我想先分开说下3者的职责</p>
<p><u><strong><em>代码分层的原则</em></strong></u></p>
<ul>
<li><strong>Model:</strong> The <strong>Model</strong> has to do with <strong>what</strong> your application does. It has nothing to do with how the app is displayed, or drawn on screen. 但是其实在我接触的大部分开发者来说，大家并不会在model中写处理逻辑的代码，只是做了一个简单的数据解析的接受层来用。这太可惜了</li>
<li><strong>Controller:</strong>  The Controller has to do with <strong>how</strong> the <strong>Model</strong> is displayed, or presented on screen (UI Logic).可以理解为C是一个中间人，他负责那个model交付于哪个view，负责view和model的一种交互</li>
<li><strong>View:</strong>  The <strong>Views</strong> are your <strong>Controller</strong>’s minions. These are the things the <strong>Controller</strong> is going to use to put things on the screen like buttons, labels, tables, etc. to display what is in the <strong>Model</strong>, and to get input from the user to update the <strong>Model.</strong> View就像个工具人，有点像我们硬件中的GPU,单纯做展示，拿到model之后就把这些数据展示到自身上</li>
</ul>
<p><u><strong><em>三者的交互</em></strong></u></p>
<ul>
<li><strong>View&amp;model</strong>： 如图中之间的黄线所示，这是不允许做任何交互的，这也是中间C的职责所在</li>
<li><strong>Model&amp;Controller:</strong> 首先,model并不允许持有C,不允许接受任何C的状态。C单方面持有Model，对其进行操作和改变。当model自身发生改变，需要通知外界时，利用KVO&amp;Notification来进行告知</li>
<li><strong>View&amp;Controller:</strong> C持有View,所以可以对View做一切操作。反过来，View并不允许持有C.但是它有着一些自己的交互方式。例如Target Action。这是Button的API，可以告诉target自己被点击了。从而做出对应的Action的响应。还有经典的tableView的delegate和source的api。都是View和controller的交互方式</li>
</ul>
<p>用一个音乐播放列表的的demo来解释这三者。首先controller会拿到10首歌曲(model)，给到view.于是view展示10条数据。但是当用户网上翻滚的时候，view滚到极限了，就会去问controller.我接下来该展示什么。于是C就找model拿更多的数据交付给View.形成整个闭环。可惜的是，大部分见到的oc开发者的model，只是个避免面向dictionary开发的数据层。</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a><a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVVM</a></h2><p>随着业务的增加，MVC中的C越来越臃肿，为了给C减负，于是衍生出VM来接替一些C的工作，例如网络请求,数据缓存…等等，保证C只做交互和控制器的跳转。</p>
<p>但是在这里我并不想说这种MVVM，我想聊聊FRP+MVVM,尽管在命令式UI中，这种方式让我们的代码依旧表现出尽可能的优雅并且可读性高。</p>
<p>在这里model和View依旧做着和MVC同样的事情，不过让我们对ViewModel做一些改造</p>
<p><img src="/swift/SwiftUI%E5%88%9D%E4%BD%93%E9%AA%8C/mvvm.png" alt="mvvm"></p>
<p>​     我们拿单独的一个页面来说讲一下：对于一个页面的展示(View)来说。这个页面来的变化只会在页面初始化，网络数据加载，以及一些用户的操作会引起页面的变化。我们把思维稍微抽象化一点。我们把用户在这个页面停留的这一串时间想象成一个数组，把用户的所有的这些行为可以理解为这个时间段上事件流有序的元素。并且提前把每个元素要对应页面改变定义好，绑定在View上,所以只要当有这个时间发生时，页面就做出相应的反应。这个相应反应的过程就是响应式UI（Reactive）,但是如何把事件流的元素转换成UI所需要的数据呢。这里需要用到函数式编程的思想(Functional)，只不过以往的函数式的操作的元素是一些基本的数据类型.我们只需要抽象一下思想，把元素集合想象成事件流，把每个事件想象成元素</p>
<p>​    这个转换的过程在那里做呢，这就是ViewModel的功能，如上图，我们在构建一个页面时，我们可以提前把所有会对UI造成影响的行为列出来，叫做Input,各种各样的Input分好类。组成Inputs,然后把UI所期待的反应的数据想象成对应的OutPuts。然后再在对应的ViewModel中去做转换。还是如上图中，可以把ViewModel理解成一个管道，进来的可能是水，在ViewModel中做了转换之后，可能是果汁，交给对应的subscriber。<br>​    <img src="/swift/SwiftUI%E5%88%9D%E4%BD%93%E9%AA%8C/code.png" alt="code"></p>
<p>上图我很多年前写的一个做比赛投彩的项目，当时有一个页面的需求是展示出所有的比赛列表，并且可以做排序。在上面我们就可以把用户点击一个日期排序按钮作为input输入，然后过滤出没有比赛的，然后转换成tableView用的数据。然后交给VC绑定给tableview。这样做的好处是什么，首先避免了大量的异步编程，大量的回调和代码会影响我们的思维一直向前的逻辑。代码阅读性高,提前在写代码之前想好构思，这样写法可以让代码按照我们的思路来走，并且更好的做单元测试。</p>
<h3 id="声明式UI"><a href="#声明式UI" class="headerlink" title="声明式UI"></a>声明式UI</h3><p>在过去的iOS的编程中，我们用到的都是命令式UI,在说到swiftui之前，想先聊聊声明式UI。那么什么是声明式UI</p>
<p>想象我们要实现下面这个界面：</p>
<p>打开开关就让下面的 label 显示 on，反之显示 off。如果我们要用非声明式的方式实现，即命令式，那么需要：</p>
<ul>
<li>创建一个 <code>UISwitch</code>，设置它的 change 事件 handler</li>
<li>创建一个 <code>UILabel</code></li>
<li>创建一个 <code>UIStackView</code>，设置方向为垂直</li>
<li>将 1、2 创建的两个视图添加到 <code>UIStackView</code> 中</li>
<li>change 事件触发时读取开关的当前状态，设置相应字符串到 label 中</li>
</ul>
<p>这样做面对一个状态，我们尚且能够正确处理，但随着应用日渐复杂，状态也越来越多并且错综复杂，状态变化的顺序甚至也能影响应用逻辑的正确性，因为我们对每个事件的处理都是对界面的增量修改。一旦前一个状态有错误，后面就会错上加错，接下来多线程混入，然后 boom，你的应用可能就 crash 了。</p>
<p>声明式的意思就是让我们描述我们需要一个什么样的界面，而不是告诉计算机一步一步干什么。那么上面的例子用声明式就是这样：</p>
<blockquote>
<p>“我需要一个界面，它是一个 VStack（垂直布局），里面有一个开关，开关的值与 switchValue 的布尔值绑定，VStack 里接下来是一个 Text，它的值当 switchValue 为 true 时是 foo，否则是 bar”</p>
</blockquote>
<p>我们可以发现，全文没有命令，都是在描述界面是怎样的。<code>switchValue</code> 我们称之为 “The Source of Truth”，Toggle 的状态、Text 的文本内容都与它相绑定。状态变化时，界面按照先前描述的重新“渲染”即可得到状态绝对正确的界面。这正是声明式的优势所在，<strong>降低状态增加时界面维护的复杂度</strong>。</p>
<h3 id="SwiftUI"><a href="#SwiftUI" class="headerlink" title="SwiftUI"></a><a href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener">SwiftUI</a></h3><p>   我个人每年都会看一下斯坦福的<a href="https://cs193p.sites.stanford.edu" target="_blank" rel="noopener">CS193P</a>来获取比较前沿而且专业的知识，这门课程真的值得一学。今年讲到了<a href="https://developer.apple.com/xcode/swiftui/" target="_blank" rel="noopener">SwiftUI</a> ,所以就跟着过了一遍。写完了几个assignments之后，前几年写mvvm+frp的感觉又回来了。而且这可是原生的mvvm，共同之处我就不再阐述，这里只是说一下额外的爽点</p>
<ul>
<li><strong>FRP的改变:</strong> 利用combine框架来代替SwiftUI,并且衍生出了很多语法糖,Property wrapper，类似@Published， @ObervedObject， @State, @Binding 等等之类的东西。在现在你如果View中的内容根据model的任何成员变量的改变而改变，那可太简单了。</li>
</ul>
<pre><code><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在viewModel中的model前加上@published，代表这个成员变量每次改动会发出信号</span></span><br><span class="line">@<span class="type">Published</span> <span class="keyword">private</span> <span class="keyword">var</span> memoryGame: <span class="type">MemoryGame</span>&lt;<span class="type">String</span>&gt; = <span class="type">EmojiMemoryGame</span>.createMemoryGame()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在View中的viewModel前加上@ObservedObject，代表观察中这个变量内部发出的信号，然后自己会在合适的时机更新ui到最新的数据</span></span><br><span class="line">@<span class="type">ObservedObject</span> <span class="keyword">var</span> emojiMemoryGame = <span class="type">EmojiMemoryGame</span>()</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p><strong>更轻量级的应用：</strong> 在SwiftUI中，所有的model应该都是结构体这个时候可以巧妙的利用stuct的<a href="https://medium.com/@marthin.pasaribu_72336/copy-on-write-cow-with-swift-ce6c6583de38" target="_blank" rel="noopener">COW</a>的机制，任何成员变量的改变都会触发信号流的刷新</p>
</li>
<li><p><strong>声明式UI:</strong> 在上上章MVVM的例子里，我们的代码依旧不可避免出命令式的代码，例如最起码的数据绑定，在声明式UI中，我们直接去View的文件中，可以直接看到页面的布局、元素、以及每个View上要绑定的数据，清晰明了</p>
</li>
</ul>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>​     在写命令式UI的代码，有时候几个月不写的代码自己回头去找布局都需要打开视图层来查找。好像声明式ui再也不会有这样的痛苦，再也不用去做各种updateUI的代码，一切所见即所得。</p>
<p>​    在爽完2周的swiftui之旅，真的感觉有点回不去了，不过等待swiftui的普及，还需要很长的路要走，希望那一天不会太远。接下来一段时间打算再看看flutter，然后再做一个对比，希望能再有所提升</p>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title>block的本质</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/block%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<p>在之前做逆向的过程中有做过block的符号表还原，大概知道有堆block栈block的概念。然后最开始学oc的时候也记得有__block的关键字。不过时间久了也有点忘了，所以干脆梳理一下</p>
<h4 id="block的底层结构"><a href="#block的底层结构" class="headerlink" title="block的底层结构"></a>block的底层结构</h4><p>首先我们可以定义一个block,然后调用class、superclass等方法来打印一下对应的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void(^block)(void) &#x3D; ^(void)&#123;</span><br><span class="line">        NSLog(@&quot;do nothing&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    NSLog(@&quot;class&#x3D;%@,spuerclass&#x3D;%@,super&amp;super&#x3D;%@&quot;,NSStringFromClass([block class]), NSStringFromClass([[block class] superclass]),NSStringFromClass([[[block class] superclass] superclass]));</span><br></pre></td></tr></table></figure>

<p>打印结果如下</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/block%E7%9A%84%E6%9C%AC%E8%B4%A8/block%E7%9A%84%E6%9C%AC%E8%B4%A81.png" alt="block的本质"></p>
<p>明显最终继承自NSObject，所以说他是对象，一点问题都没有。至于他本来为什么是NSGlobalBlock，这个先不探究。后面再说</p>
<p>另外，我们可以把这段代码用clang编译成c++，看看更加清晰的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现我们之前定义的block其实就是这么一串代码。其实去掉类型转换的代码，可以理解为创建了这么一个简单的block的原始代码是这样的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA))</span><br></pre></td></tr></table></figure>

<p>看起来像去调用一个函数，然后传了2个参数。我们搜索一下__main_block_impl_0，然后发现了这个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很明显，之前创建block的函数就是调用的这个结构体的构造函数，然后分别找一下2个成员block的结构体实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"><span class="comment">// 创建了结构体，第一个参数传了0，第二个参数是自己的大小</span></span><br></pre></td></tr></table></figure>

<p>然后我们注意一下我们创建block时候的2个参数，其中一个<strong>main_block_desc_0_DATA在上面的代码已经找到了。还有</strong>main_block_func_0赋值给了block结构体中的__block_impl的FuncPtr。很明显这个结构体就是放的函数实现的一些相关信息，FuncPtr就是实现的函数地址的指针，找到这个func_o看看</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_p8_b47b91tx76z5kbh2cxh9d83r0000gn_T_main_b590d7_mi_0);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>其实到这里我们就可以用图稍微总结一下</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/block%E7%9A%84%E6%9C%AC%E8%B4%A8/block%E7%9A%84%E6%9C%AC%E8%B4%A82.png" alt="block的本质"></p>
<p>通过这个isa我们也可以说明确实是一个对象，但是这是一个最简单的block，他只是做了简单的一句打印，连变量都没访问。我们将代码稍微复杂一点</p>
<h4 id="block的变量捕获"><a href="#block的变量捕获" class="headerlink" title="block的变量捕获"></a>block的变量捕获</h4><p>最开始还是通过swift闭包的捕获列表了解到捕获这个词的，等熟悉了之后才觉得这个词非常准确。这次我们实现一个稍微复杂一点的block，我们分别定义了一个普通的局部变量，还有一个static的局部变量，还有一个全局变量，并且在block中访问他们</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int globleC_ &#x3D; 5;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        int a &#x3D; 2;</span><br><span class="line">        static int b &#x3D; 3;</span><br><span class="line">        </span><br><span class="line">        void(^block)(void) &#x3D; ^(void)&#123;</span><br><span class="line">            NSLog(@&quot;%d%d%d&quot;,a,b,globleC_);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次我们还是通过clang来编译一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, &amp;b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现比之前多了2个参数，一个是a,一个是b的地址,c并没有传。然后我们看看对应的几个结构体，发现两个子结构体没有改变，只有block自身做了变动</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> *b;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _a, <span class="keyword">int</span> *_b, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a), b(_b) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>很明显，多一个一个int a,以及一个int 的指针b。而且通过构造函数也知道是把外部的这2个值直接做了赋值。而全程没有看到c,然后再看下block内部实现的编译结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line">  <span class="keyword">int</span> *b = __cself-&gt;b; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p8_b47b91tx76z5kbh2cxh9d83r0000gn_T_main_ef3981_mi_0,a,(*b),globleC_);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>明显通过block拿到了对应的2个值，然后调用了NSLog。而globleC_则是直接取的全局变量。</p>
<p>唯一的不同一个捕获普通变量是传的值，而static传的是指针，其实对这个普通变量我们有另外一种专业的称呼，叫做auto变量。默认情况下，所有的局部变量都是auto局部变量。通过这个捕获关系，我们也可以总结如图</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/block%E7%9A%84%E6%9C%AC%E8%B4%A8/block%E7%9A%84%E6%9C%AC%E8%B4%A83.png" alt="block的本质"></p>
<h4 id="block捕获对象"><a href="#block捕获对象" class="headerlink" title="block捕获对象"></a>block捕获对象</h4><p>在上面我们捕获的基础变量，这次我们试试对象类型</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">        <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,obj)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成c++，结果如下，由于_block_impl_这个结构体没有改动，所以就不贴出来</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// block本体结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  NSObject *obj;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, NSObject *_obj, <span class="keyword">int</span> flags=<span class="number">0</span>) : obj(_obj) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// block的函数具体实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  NSObject *obj = __cself-&gt;obj; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_p8_b47b91tx76z5kbh2cxh9d83r0000gn_T_main_138f73_mi_0,obj);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block中第二个结构体__main_block_desc_0的实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面这个结构体中的2个函数 copy 和dispose的实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;obj, (<span class="keyword">void</span>*)src-&gt;obj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;obj, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        NSObject *obj = ((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((NSObject *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"NSObject"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, obj, <span class="number">570425344</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在创建block的时候是直接把obj传递了进去，然后结构体内部也有一个NSObject *obj来接收，这点没有问题，因为obj默认是个auto NSObjcet *类型的auto变量，所以直接来接收。</p>
<p>注意的是block中的desc结构体内部多了2个函数copy和dispose。而且在初始化结构体的时候把对应的实现传进去。而这两个函数内部分别调用的<em>_Block_object_assign*和</em>_Block_object_dispose*来做了对应的调用，而且这两个函数的参数都是结构体内部捕获的obj。</p>
<p>很明显，从函数名就知道这是做内存管理的操作,因为这是在ARC。我们也可以总结出，对应对象变量来说和普通变量没什么区别，只不过会生成额外的函数来做内存管理</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过上面这些研究，我们可以大声说block本质上也是一个OC对象，它内部也有个isa指针，只不过是一个封装了函数调用以及函数调用环境的OC对象。可以更加全面的用这个图来表示</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/block%E7%9A%84%E6%9C%AC%E8%B4%A8/block%E7%9A%84%E6%9C%AC%E8%B4%A84.png" alt="block的本质"></p>
<p>另外我们在创建最简单的block的时候发现他的类型是一个global的，那么他有没有其他类型呢。还有在block内部修改捕获变量会发生什么事呢？</p>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>iOS中的内存分配</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/iOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近朋友有问一道面试题<strong>一个NSObject对象占用多少内存</strong>，以及说出为什么，所以对这方面做一个研究，也算自己对相关的知识做一个整理</p>
<h4 id="获取对象内存的大小"><a href="#获取对象内存的大小" class="headerlink" title="获取对象内存的大小"></a>获取对象内存的大小</h4><p>在日常编程中，一般很少会用到类似的api,但是其实runtime中是有这方面的api的。例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Returns the size of instances of a class.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param cls A class object.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The size in bytes of instances of the class \e cls, or \c 0 if \e cls is \c Nil.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">size_t</span></span><br><span class="line">class_getInstanceSize(Class _Nullable cls) </span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>

<p> 以及</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">size_t</span> <span class="title">malloc_size</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line">    <span class="comment">/* Returns size of given ptr */</span></span><br></pre></td></tr></table></figure>

<p>所以我们可以直接用这两个函数分别获得结果打印一下，就能获得结果</p>
<h4 id="内存的最小分配值"><a href="#内存的最小分配值" class="headerlink" title="内存的最小分配值"></a>内存的最小分配值</h4><p>说干就干，导入对应的头文件，然后写代码直接跑起来验证一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *obj &#x3D; [[NSObject alloc] init];</span><br><span class="line">NSLog(@&quot;%zu&quot;,class_getInstanceSize(NSObject.class));</span><br><span class="line">NSLog(@&quot;%zd&quot;,malloc_size((__bridge const void *)(obj)));</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/iOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/log1.png" alt="iOS中的内存分配"></p>
<p>但是结果和我们想象的有出入，所以必须解惑一下。点进NSObject的头文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实里面就只有一个成员变量，至于方法这些肯定是不会放在对象的分配内存中的，如果不懂这一块的就先记住这个点就好了。</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/iOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/isa.png" alt="iOS中的内存分配"></p>
<p>唯一的一个成员变量也就是isa,其实是一个结构体指针。按理来说就只有8个字节，而且通过class_getInstanceSize来验证确实也是8。但是操作系统分配内存为什么是16呢。查了下资料知道了大概，但是还是去找<a href="nhttps://opensource.apple.com/tarballs/objc4/">runtime的源码</a>来看一看。</p>
<p>我们都知道我们对象分配内存都是调用的alloc，以及下层的allocWithZone。于是跟进源码可以到这一步</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((always_inline)) </span><br><span class="line">id</span><br><span class="line">_class_createInstanceFromZone(Class cls, <span class="keyword">size_t</span> extraBytes, <span class="keyword">void</span> *zone, </span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>, </span><br><span class="line">                              <span class="keyword">size_t</span> *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    <span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">            obj = (id)malloc_zone_calloc ((<span class="keyword">malloc_zone_t</span> *)zone, <span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj = (id)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">size</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be </span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现最底层根据不同的调用调用不同的c函数来分配内存，分配一个size的内存，size是通过cls-&gt;instanceSize(extraBytes)来得来的。我们跟进去发现代码是这样的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class's ivar size rounded up to a pointer-size boundary.</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; <span class="number">16</span>) <span class="built_in">size</span> = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实对于NSObjcet来说alignedInstanceSize是8个字节，恰好是他成员变量的大小，这是合理的。但是由于 CF requires all objects be at least 16 bytes.所以补足到了16。btw，alignedInstanceSize其实就是class_getInstanceSize的底层实现。</p>
<p>其实我们可以这么理解</p>
<p>class_getInstanceSize理解为创建一个实例对象，至少需要多少内存。</p>
<p>而malloc_size获取的是实际上分配了多少内存，毕竟我们看到源码corefoundation还有一个最少16字节的规则。而且后面还有内存对齐的规则。</p>
<h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><p>其实接下来，我们可以探究一下内存对齐的问题。从代码来说，我们定义这么一个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject &#123;</span><br><span class="line">    @public</span><br><span class="line">    int _age;</span><br><span class="line">    int _height;</span><br><span class="line">    int _weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这个类继承自NSobject,所以他的成员变量应该依次是isa、_age、_height、_weight。isa8个字节，age height weight个4个字节，12+8=20，然后结构体内存需要对齐，所以是24字节。我们也可以验证一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *p1 &#x3D; [[Person alloc] init];</span><br><span class="line">NSLog(@&quot;%zu&quot;,class_getInstanceSize(Person.class));</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/iOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/log2.png" alt="iOS中的内存分配"></p>
<p>没错，确实是24，但是通过我们上面学的知识，我们觉得还是用malloc来打印一下比较靠谱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *p1 &#x3D; [[Person alloc] init];</span><br><span class="line">NSLog(@&quot;%zu&quot;,class_getInstanceSize(Person.class));</span><br><span class="line">NSLog(@&quot;%zd&quot;,malloc_size((__bridge const void *)(p1)));</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/iOS%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/log3.png" alt="iOS中的内存分配"></p>
<p>脑底里大大的几个问号，为什么是32啊。按理说24&gt;16了啊，不用做什么内存补足了，为什么还是分配了32呢，直觉告诉我是做了操作系统层的内存对齐。于是再去找一下对应的资料，在上面分配内存的代码最终走到calloc。于是我们下载libmalloc的源码。最终可以跟到这里</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">segregated_size_to_fit(<span class="keyword">nanozone_t</span> *nanozone, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> *pKey)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> k, slot_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">size</span>) &#123;</span><br><span class="line">        <span class="built_in">size</span> = NANO_REGIME_QUANTA_SIZE; <span class="comment">// Historical behavior</span></span><br><span class="line">    &#125;</span><br><span class="line">    k = (<span class="built_in">size</span> + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM; <span class="comment">// round up and shift for number of quanta</span></span><br><span class="line">    slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;                            <span class="comment">// multiply by power of two quanta size</span></span><br><span class="line">    *pKey = k - <span class="number">1</span>;                                                    <span class="comment">// Zero-based!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slot_bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实(size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM这一行就在做内存对齐，对齐的大小就是NANO_REGIME_QUANTA_SIZE</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NANO_MAX_SIZE            256 <span class="comment">/* Buckets sized &#123;16, 32, 48, 64, 80, 96, 112, ...&#125; */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT_NANO_QUANTUM        4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NANO_REGIME_QUANTA_SIZE        (1 &lt;&lt; SHIFT_NANO_QUANTUM)    <span class="comment">// 16</span></span></span><br></pre></td></tr></table></figure>

<p>1&lt;&lt;4就是16，即16字节对齐</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>截止到这里，我们已经知道了iOS中分配内存的补足，也知道了有操作系统级的内存对齐。也知道了class_getInstanceSize和malloc_size的区别，相信也知道遇到这种问题该怎么回答了</p>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>fishhook原理</title>
    <url>/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/fishhook%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="fishhook简介"><a href="#fishhook简介" class="headerlink" title="fishhook简介"></a>fishhook简介</h3><p>fishhook 是一个由 facebook 开源的第三方框架，其主要作用就是<strong>动态修改 C 语言函数实现</strong>。</p>
<p>这个框架的代码其实非常的简单，只包含两个文件：<code>fishhook.c</code> 以及 <code>fishhook.h</code>；两个文件所有的代码加起来也不超过 300 行。</p>
<p> 不过它的实现原理是非常有意思并且精妙的，不过在这之前，先让我们简单尝试一下</p>
<h3 id="Fishhook-简单使用"><a href="#Fishhook-简单使用" class="headerlink" title="Fishhook 简单使用"></a>Fishhook 简单使用</h3><p>例如，我hook一个系统的NSLog方法，大概的代码就是这样</p>
<blockquote>
<p>1.写一个自己的func来做hook的事，例如文中的MYLog</p>
<p>2.定义一个函数指针用来保存被hook的函数，方便后续调用</p>
<p>3.创建一个<code>rebinding</code>结构体，给三个参数赋值，然后调用<code>rebind_symbols</code>，一个hook就已经完成</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)hook</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> <span class="title">logRebind</span>;</span></span><br><span class="line">    logRebind.name = <span class="string">"NSLog"</span>;</span><br><span class="line">    logRebind.replacement = MyLog;</span><br><span class="line">    logRebind.replaced = (<span class="keyword">void</span> *)&amp;originalNSLog;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> <span class="title">rebs</span>[] = &#123;</span>logRebind&#125;;    </span><br><span class="line">    rebind_symbols(rebs, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*originalNSLog)</span><span class="params">(NSString *format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyLog</span><span class="params">(NSString *format, ...)</span></span>&#123;</span><br><span class="line">    <span class="comment">// do sth you  want</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// orignal func</span></span><br><span class="line">    originalNSLog(format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信有很多人和我一样有一些不解，OC的runtime是基于OC动态运行时的本质做了交换，但是NSLog是一个C语言函数，是静态的。这是如何做到的呢？这些可以在fishhook的源码中可以找到，不过在这之前，我们先补充一点基础 知识</p>
<h3 id="前瞻理论"><a href="#前瞻理论" class="headerlink" title="前瞻理论"></a>前瞻理论</h3><p>我们上面示例代码中，NSLog是一个属于Foundation的库的函数，在编译过程中，其实他并不在我们文件中。对于我们应用程序来说，本质是一个二进制执行文件，有个更专业的词，叫<a href="https://zh.wikipedia.org/wiki/Mach-O" target="_blank" rel="noopener">MachO</a>,当<a href="https://zh.wikipedia.org/wiki/Mach-O" target="_blank" rel="noopener">MachO</a>被内核加载到内存中开始运行时，有一个叫<a href="https://en.wikipedia.org/wiki/Dynamic_linker" target="_blank" rel="noopener">DYLD</a>做了一系列的事情，其中一步叫做加载共享缓存区(shareCache),DYLD做了一系列的加载链接。那么苹果如果在编译时保证这种并不确定的静态呢，苹果为了能在 Mach-O 文件中访问外部函数，采用了一个技术，叫做<a href="https://en.wikipedia.org/wiki/Position-independent_code" target="_blank" rel="noopener">PIC</a>（位置代码独立）技术。</p>
<p>当你的应用程序想要调用 Mach-O 文件外部的函数的时候，或者说如果 Mach-O 内部需要调用系统的库函数时，Mach-O 文件会：</p>
<blockquote>
<ol>
<li>先在 Mach-O 文件的 _DATA 段中建立一个指针,这个指针变量指向外部函数。</li>
<li>DYLD 会动态的进行绑定！将 Mach-O 中的 _DATA 段中的指针，指向外部函数。</li>
</ol>
</blockquote>
<p>fishhook本质就是找这个符号名，已经把这个符号名的符号给替换掉的过程，下面可以通过2张图简单了解一下</p>
<h3 id="Fishhook-原理简单图解"><a href="#Fishhook-原理简单图解" class="headerlink" title="Fishhook 原理简单图解"></a>Fishhook 原理简单图解</h3><p>1.寻址,本质就是对MachO文件中的几个表的对应关系的查找，感兴趣的可以深入的了解下MachO,后面的源码也会简单的说明</p>
<p><img src="https://camo.githubusercontent.com/18243516844d12b1bd158ce3687635d6e48d2e2e/687474703a2f2f692e696d6775722e636f6d2f4856587148437a2e706e67" alt="Visual explanation"></p>
<p>2.替换</p>
<p><img src="/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/fishhook%E5%8E%9F%E7%90%86/simpleTheory.png" alt="simpleTheory"></p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>首先入口函数<code>rebind_symbols</code>,接受一个<code>rebinding</code>结构体的数组，以及他的数组长度。可以一次hook多个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册重新绑定符号的回调时机</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将需要hook的结构体链接成链表结构(之所以使用链表是因为在C语言中，处理这种预先不知道可能有多少个的集合来讲，链表是比较好的选择)</span></span><br><span class="line">  <span class="keyword">int</span> retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    <span class="comment">//此处的异常主要用来处理malloc开辟空间失败</span></span><br><span class="line">  <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If this was the first call, register callback for image additions (which is also invoked for</span></span><br><span class="line">  <span class="comment">// existing images, otherwise, just run on existing images</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     如果是第一次调用重新绑定符号的方法，就通过注册添加image(target module)的方法回调来重新绑定符号(这个方法在任何地方注册都会执行加载image的回调);</span></span><br><span class="line"><span class="comment">     如果不是第一次调用重新绑定符号的方法，就通过遍历当前已经加载的image来循环绑定符号(如果在此操作执行之后，又重新加载了image，可以通过_dyld_register_func_for_add_image来监听到);</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在方法内部调用rebind_symbols_for_image实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> struct mach_header *header,</span><br><span class="line">                                      <span class="keyword">intptr_t</span> slide) &#123;</span><br><span class="line">    rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取链接表，符号表，动态符号表，重定向(<a href="[https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9D%80%E7%A9%BA%E9%96%93%E9%85%8D%E7%BD%AE%E9%9A%A8%E6%A9%9F%E8%BC%89%E5%85%A5](https://zh.wikipedia.org/wiki/位址空間配置隨機載入)">ASLR</a>)表在内存中的地址，获取<strong>la_symbol_ptr以及</strong>ln_symbol_ptr对应的section，方便找到后续的对应的两个表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> struct mach_header *header,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">intptr_t</span> slide)</span> </span>&#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一次遍历load Commands主要是为了找到链接表linkedit_segment,符号表(symtab_cmd),动态符号表(dysymtab_cmd)对应的load command</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);<span class="comment">//使用uintptr_t类型主要是为了方便按照字节为单位移动指针的位置</span></span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 通过使用__LINKEDIT的起始地址找到symbol table/string table在内存中的地址</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  <span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff); <span class="comment">//使用char *类型是因为字符在内存中按照char为单位进行存储</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取重定向表在内存中的位置</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff); <span class="comment">//使用uint32_t *是因为重定向符号表中数据按照4字节为单位进行存储</span></span><br><span class="line"> </span><br><span class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">       <span class="comment">//找到DATA和DATA_CONST segment，并跳过</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">////找到__nl_symbol_ptr和__la_symbol_ptr这两个section</span></span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        <span class="keyword">section_t</span> *sect =</span><br><span class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">            <span class="comment">//遍历懒加载符号表中的符号，与_rebindings_head进行比较，对匹配的符号进行重新绑定</span></span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">            <span class="comment">//遍历非懒加载符号表中的符号，与_rebindings_head进行比较，对匹配的符号进行重新绑定</span></span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找并替换_rebindings_head中需要替换的符号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">section_t</span> *section,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">nlist_t</span> *symtab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">char</span> *strtab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">uint32_t</span> *indirect_symtab)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//section在indirect table中的索引从reserved1处开始</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">    <span class="comment">// //indirect Symbols中包含了各个section中符号在Symbol Table的index，这里是直接定位到对应__DATA,__la_symbol_ptr所在的index数组</span></span><br><span class="line">  <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;<span class="built_in">size</span> / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</span><br><span class="line">      <span class="comment">//获取indirext table中对应索引处的值，该值表示在symbole table中的索引</span></span><br><span class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">      <span class="comment">//如果该索引表示的符号是未绑定前的符号或者本地符号，则不进行任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//获取在string table中偏移</span></span><br><span class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">      <span class="comment">//获取在string table中的地址</span></span><br><span class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></span><br><span class="line">      <span class="comment">//遍历找到需要重新绑定的符号,进行重新绑定</span></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(symbol_name) &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//防止重复绑定</span></span><br><span class="line">          <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">              <span class="comment">//如果符号对应的实现不是自定义实现，说明符号没有还重新绑定，将符号对应的真实实现存入cur-&gt;rebindings[j].replaced对应位置</span></span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="comment">//将自定义实现，存入符号对应的位置</span></span><br><span class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">            <span class="comment">// 跳出，避免多次绑定</span></span><br><span class="line">          <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否能hook在项目或者静态库中的定义的C函数"><a href="#是否能hook在项目或者静态库中的定义的C函数" class="headerlink" title="是否能hook在项目或者静态库中的定义的C函数"></a>是否能hook在项目或者静态库中的定义的C函数</h3><p>答案是不能！！！因为无论在项目中还是静态库中的函数，在编译的时候它们的地址就已经确定(Mach-O基地址+偏移)，它们不会存在于<code>__la_symbol_ptr</code>表中，自然也就无法更改。</p>
]]></content>
      <categories>
        <category>源码解读</category>
      </categories>
  </entry>
  <entry>
    <title>iOS卡顿监控遇到的一些难题</title>
    <url>/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/iOS%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%8E%A7%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9A%BE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近一段时间在做卡顿的治理，目前项目中集成的是bugly，在解决了一些基础的问题之后。数据并没有降低到预期，于是要着手解决一些难的问题。但是bugly上对于卡顿的监控只能看到调用栈，很多复杂的问题上传的调用栈都是系统底层的调用栈。并不能帮我们进一步定位问题。</p>
<h3 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h3><p>其实我们希望我们的卡顿监控是这样的。</p>
<blockquote>
<p>1.可以看到卡顿的调用栈(基本) </p>
<p>2.可以能看到一些页面的追踪，例如进入了xx页面，退到了后面，进入了前台…等等消息</p>
<p>3.最好能带上一些自定义的信息。例如用户信息等</p>
</blockquote>
<p>其实这3点bugly的crash监控是有做到的，错误的跟踪也是有做到的。但是唯独只有卡顿监控只有单一的调用栈。找遍了所有的自定义interface。并没有提供类似的补充功能。(btw，我觉得这应该在实现上没有什么太大的麻烦)可能是大多数应用对卡顿的数据并不敏感。而大厂都有自己的apm平台。所以我们只能根据我们自己的需求做一些其他方向的思考。</p>
<h3 id="进一步的调查"><a href="#进一步的调查" class="headerlink" title="进一步的调查"></a>进一步的调查</h3><p>进过上一步的思考，我们定位了自己的需求。但是对于我个人而言，还是希望能用一些现成的东西，在时间成本上比较划算（主要是自己懒）。所以最开始的想法是想换一下别家的sdk。所以有了下面的调查</p>
<blockquote>
<p>1.网易云捕快: 好像有类似的功能，但是不提供试用。公司应该也不会批准在这方面产品额外的费用。所以pass</p>
<p>2.阿里的岳鹰: 新推出的产品，试过之后发现目前没有提供卡顿的监控，暂时不提供对外的自定义日志功能</p>
<p>3.firebase: 不得不说这真的是做得很好的一个产品。各方面都很全面,展示得也非常清晰。可惜的是，也没有类似的卡顿功能</p>
</blockquote>
<p>在经历了这些之后，我们只能另辟蹊径。但是目前我们的时间和人力并不允许我们去做一个完善的apm(虽然我觉得这是很早就应该做的东西)。所以我们只能想其他方法。尽量低成本以及完善的办法</p>
<h3 id="另辟蹊径"><a href="#另辟蹊径" class="headerlink" title="另辟蹊径"></a>另辟蹊径</h3><p>其实无论是以后自己做apm还是目前要想其他办法。卡顿的监控肯定是需要自己来实现了。只是上报到自己的apm后台还是第三方的后台的区别罢了。所以第一步就先实现自己的卡顿监控</p>
<p>关于iOS的卡顿监控这一点网络上已经讨论烂了，并不是什么复杂的技术。但是我们的管理层还是要看bugly的数据，所以我们就按bugly的实现方式来仿写一遍好了。在bugly的文档上，我们有看到这一段</p>
<blockquote>
<h4 id="检查卡顿的依据和上报时机是什么"><a href="#检查卡顿的依据和上报时机是什么" class="headerlink" title="检查卡顿的依据和上报时机是什么?"></a>检查卡顿的依据和上报时机是什么?</h4><blockquote>
<p>iOS 卡顿检查的依据是监控主线程 Runloop 的执行，观察执行耗时是否超过预定阀值(默认阀值为3000ms) 在监控到卡顿时会立即记录线程堆栈到本地，在App从后台切换到前台时，执行上报。</p>
</blockquote>
</blockquote>
<p>所以我们就直接按这个仿写一个。用信号量来监控，间隔3s RunLoop无响应就代表产生的一次卡顿。在后续的测试中发现bugly的确是这样做的，尽管静态库看不到源码，但是我们还是能和bugly一样监测到同样的卡顿，并且拿到同样的函数调用栈，接下来就是后续的上报的问题了。也就是一开始我们需要解决的问题。</p>
<h3 id="上报方案之一FireBase"><a href="#上报方案之一FireBase" class="headerlink" title="上报方案之一FireBase"></a>上报方案之一<a href="https://firebase.google.com" target="_blank" rel="noopener">FireBase</a></h3><p>尽管在之前我们调研firebase的时候有提到过。firebase并不支持卡顿的一些监控。但是他支持自定义的异常上报的sdk。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Records an Exception Model described by an FIRExceptionModel object. The events are</span></span><br><span class="line"><span class="comment"> * grouped and displayed similarly to crashes. Keep in mind that this method can be expensive.</span></span><br><span class="line"><span class="comment"> * The total number of FIRExceptionModels that can be recorded during your app's life-cycle is</span></span><br><span class="line"><span class="comment"> * limited by a fixed-size circular buffer. If the buffer is overrun, the oldest data is dropped.</span></span><br><span class="line"><span class="comment"> * Exception Models are relayed to Crashlytics on a subsequent launch of your application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param exceptionModel Instance of the FIRExceptionModel to be recorded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)recordExceptionModel:(FIRExceptionModel *)exceptionModel</span><br><span class="line">    NS_SWIFT_NAME(record(exceptionModel:));</span><br></pre></td></tr></table></figure>

<p>其中这个exceptionModel的一些接口方法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an Exception Model model with the given required fields.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param name - typically the type of the Exception class</span></span><br><span class="line"><span class="comment"> * @param reason - the human-readable reason the issue occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (instancetype)exceptionModelWithName:(NSString *)name</span><br><span class="line">                                reason:(NSString *)<span class="function">reason <span class="title">NS_SWIFT_UNAVAILABLE</span><span class="params">(<span class="string">""</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A list of Stack Frames that make up the stack trace. The order of the stack trace is top-first,</span></span><br><span class="line"><span class="comment"> * so typically the "main" function is the last element in this list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">@property(nonatomic, copy) NSArray&lt;FIRStackFrame *&gt; *stackTrace;</span><br></pre></td></tr></table></figure>

<p>提供了一个异常，以及原因。并且需要传入对应的调用栈帧。可以进一步进去看下这个<code>FIRStackFrame</code>这个类,发现他提供了一些并不简便的方法，需要上传的时候自己找到发生问题的文件。以及行数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes a symbolicated Stack Frame with the given required fields. Symbolicated</span></span><br><span class="line"><span class="comment"> * Stack Frames will appear in the Crashlytics dashboard as reported in these fields.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param symbol - The function or method name</span></span><br><span class="line"><span class="comment"> * @param file - the file where the exception occurred</span></span><br><span class="line"><span class="comment"> * @param line - the line number</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (instancetype)initWithSymbol:(NSString *)symbol file:(NSString *)file <span class="built_in">line</span>:(NSInteger)<span class="built_in">line</span>;</span><br></pre></td></tr></table></figure>

<p>例如下面就是文档推荐的用法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FIRExceptionModel *model =</span><br><span class="line">    [FIRExceptionModel exceptionModelWithName:@<span class="string">"FooException"</span> reason:@<span class="string">"There was a foo."</span>];</span><br><span class="line">model.stackTrace = @[</span><br><span class="line">  [FIRStackFrame stackFrameWithSymbol:@<span class="string">"makeError"</span> fileName:@<span class="string">"handler.js"</span> lineNumber:<span class="number">495</span>],</span><br><span class="line">  [FIRStackFrame stackFrameWithSymbol:@<span class="string">"then"</span> fileName:@<span class="string">"routes.js"</span> lineNumber:<span class="number">102</span>],</span><br><span class="line">  [FIRStackFrame stackFrameWithSymbol:@<span class="string">"main"</span> fileName:@<span class="string">"app.js"</span> lineNumber:<span class="number">12</span>],</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>很明显在我们发生卡顿的时候我们自己再去检索到对应的文件以及行数是不可行的。所以我们需要找找其他的方法,这里就不卖关子了，在读interface的时候，发现了一个这样的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * This class is used in conjunction with recordExceptionModel to record information about</span><br><span class="line"> * non-ObjC&#x2F;C++ exceptions. All information included here will be displayed in the Crashlytics UI,</span><br><span class="line"> * and can influence crash grouping. Be particularly careful with the use of the address property.</span><br><span class="line"> *If set, Crashlytics will attempt symbolication and could overwrite other properities in the</span><br><span class="line"> *process.</span><br><span class="line"> **&#x2F;</span><br><span class="line">@interface FIRStackFrame (Private)</span><br><span class="line"></span><br><span class="line">+ (instancetype)stackFrame;</span><br><span class="line">+ (instancetype)stackFrameWithAddress:(NSUInteger)address;</span><br></pre></td></tr></table></figure>

<p>很明显，这个文件是私有的，而且注释中告诉我们要用address这个api时一定要小心。ok,我们当然知道要小心，这个太适合我们了。因为我们在做卡顿监控的时候我们已经可以拿到函数调用栈的栈帧。直接调用就可以了。</p>
<p>最后的代码可能就是这个样子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NSMutableArray *callFrames = [NSMutableArray arrayWithCapacity:backtraceLength];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; backtraceLength; k++)&#123;</span><br><span class="line">    NSUInteger addr = backtraceBuffer[k];</span><br><span class="line">    FIRStackFrame *sf = [FIRStackFrame stackFrameWithAddress:addr];</span><br><span class="line">    [callFrames addObject:sf];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FIRExceptionModel *exceptionModel = [FIRExceptionModel exceptionModelWithName:@<span class="string">"jank exception"</span> reason:@<span class="string">"main thread blocked"</span>];</span><br><span class="line">exceptionModel.stackTrace = callFrames;</span><br><span class="line">[[FIRCrashlytics crashlytics] recordExceptionModel:exceptionModel];</span><br></pre></td></tr></table></figure>

<p>然后再配合<code>Firebase</code>自带的log功能，在一些生命周期(例如前后台切换，页面的加载)的地方做好log，这样我们就可以在监控到卡顿的同时可以了解到用户的一些使用踪迹了，方便我们debug。另外他还提供了<code>Add custom keys</code>的功能，这样我们也可以附带一些用户属性上去，比如用户id。等等之类的，都有助于我们定位问题。</p>
<p>其实到这里这个方案就差不多结束了，在这点上<code>Firebase</code>做得真的很好，他会做好符号化并且归类。可能比较麻烦的是在集成以及处理符号表上传的时候。btw,在调查阿里的岳鹰sdk的时候，他们是说他们也有这个对应的sdk的，但是暂时不提供对外服务。真是可惜了</p>
<h3 id="上报方案之二-Bugly"><a href="#上报方案之二-Bugly" class="headerlink" title="上报方案之二 Bugly"></a>上报方案之二 Bugly</h3><p>相对于firebase来说，bugly可能就没那么友好，但是并不是每个团队都会因为卡顿这种事情去换一个sdk的。所以也必须讨论下这种方法的可行性。</p>
<p>聚焦于我们的目标，我们只需要卡顿监控中带上用户的轨迹追踪信息，以及上报一些自定义的hash map。前言中我们有写到过，其实他sdk中crash以及异常的上报都是自己附带这些数据上去的，非常简单。</p>
<p>而且他也提供了一个自定义异常的接口方法。如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    @brief 上报自定义错误</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    @param category    类型(Cocoa=3,CSharp=4,JS=5,Lua=6)</span></span><br><span class="line"><span class="comment"> *    @param aName       名称</span></span><br><span class="line"><span class="comment"> *    @param aReason     错误原因</span></span><br><span class="line"><span class="comment"> *    @param aStackArray 堆栈</span></span><br><span class="line"><span class="comment"> *    @param info        附加数据</span></span><br><span class="line"><span class="comment"> *    @param terminate   上报后是否退出应用进程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">void</span>)reportExceptionWithCategory:(NSUInteger)category</span><br><span class="line">                               name:(NSString *)aName</span><br><span class="line">                             reason:(NSString *)aReason</span><br><span class="line">                          callStack:(NSArray *)aStackArray</span><br><span class="line">                          extraInfo:(NSDictionary *)info</span><br><span class="line">                       terminateApp:(BOOL)<span class="built_in">terminate</span>;</span><br></pre></td></tr></table></figure>

<p>和<code>Firebase</code>很像，传名称，原因,以及调用栈，但是有所不同的是，StackArray内的元素必须是String类型。也就是说，你必须自己做好符号化上传。并且，查遍了sdk，并没有通过地址上传的方法。</p>
<p>所以我们只能硬着头皮上传自己本地符号化好的数据上去。其实网上提供的监控方法后续也提供了符号化的代码。其实大概的原理和我上一篇文章类似，都是几个表之间的匹配和查找。详情可以查看<a href="https://www.qingheblog.online/源码解读/fishhook原理/" target="_blank" rel="noopener">fishhook原理</a>。</p>
<p>但是需要注意一点的是，我们的release包是做了去符号表处理的。按理说我们应该是上传的函数地址，然后统一由后台用符号化文件去做处理，然后做展示的。但是目前条件有限，我们只能用这种本地符号化的方案来做.由于脱了符号表,所以本地符号化是非常片面的。能符号化的只是很小的系统底层函数的一部分。</p>
<p>但是，我们也可以利用这些仅有的信息来做很多的事情，在上传了之后，我们可以根据库的名字，和一些符号表，来和bugly自带的卡顿监控做匹配，配合起来看。巧妇难为无米之炊，也只能这样了。最终还是要转到自己的apm平台的</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实，说到底，这两种方案都是为了在卡顿监控的基础上追加一些信息，方便我们定位问题。具体的取舍还是要看团队，其实到最后。我们还是需要自己的一个apm平台，不过，这个后续再说吧。</p>
]]></content>
      <categories>
        <category>工作总结</category>
      </categories>
  </entry>
  <entry>
    <title>iOS的web离线化</title>
    <url>/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/iOS%E7%9A%84web%E7%A6%BB%E7%BA%BF%E5%8C%96/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>由于现在公司主要业务的页面需求动态发版的能力，所以大多数页面都转向h5了，开句玩笑的话，真的是”客二消”，基于这些，为了用户的体验，所以客户端和前端一起做了个整个web的加速，当然离线化是很重要的一环，就拿出来单独的讲。</p>
<h4 id="整个方案的流程"><a href="#整个方案的流程" class="headerlink" title="整个方案的流程"></a>整个方案的流程</h4><p><img src="/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/iOS%E7%9A%84web%E7%A6%BB%E7%BA%BF%E5%8C%96/weoffline.png" alt="iOS的web离线化"></p>
<p>如上图所示，先从宏观的角度来看整体方案。整体方案大概分为以下几步：</p>
<ul>
<li><p>整个方案的起始点归于前端，我们在前端的发版自动化中做一个插桩，功能是打出当前版本的完整离线包和对比过往版本的查分包，上传到后台的包服务器，这个查分包的的版本数可以做一个阈值处理</p>
</li>
<li><p>在后端服务器，接收到这个包的同时会生成关于这个包的一些配置文件，供客户端做对比以及请求</p>
</li>
<li><p>客户端每次根据自己本地的配置去服务器换取对应的最新配置，然后经过一系列的请求、下载、合并、解压、以及以上操作的异常处理，然后更新本地的配置，方便下一次使用。到了这个时候，整个宏观的闭环结束，剩下的就是最简单也是最重要的资源的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*! 新版本 *&#x2F;</span><br><span class="line">@property(nonatomic, copy) NSString *version;</span><br><span class="line">@property (strong, nonatomic) NSString *patchUrl;       &#x2F;&#x2F;差异包</span><br><span class="line">@property (strong, nonatomic) NSString *buildUrl;       &#x2F;&#x2F;整包</span><br><span class="line">@property (strong, nonatomic) NSString *bundleMD5;      &#x2F;&#x2F;加密MD5值</span><br><span class="line"></span><br><span class="line">&#x2F;*! 该页面url对应的md5 *&#x2F;</span><br><span class="line">@property(nonatomic, copy) NSString *individualKey;</span><br><span class="line"></span><br><span class="line">&#x2F;*! 优先级 *&#x2F;</span><br><span class="line">@property(nonatomic, assign) NSInteger priority;</span><br><span class="line">&#x2F;*! 拦截白名单  *&#x2F;</span><br><span class="line">@property(nonatomic, strong) NSArray&lt;NSString *&gt; *whitelist;</span><br><span class="line"></span><br><span class="line">&#x2F;*! 什么网络下进行更新 *&#x2F;</span><br><span class="line">@property(nonatomic, assign) WebOfflineNetworkEnableType networkType;</span><br><span class="line"></span><br><span class="line">&#x2F;*! 最低允许使用版本（离线包版本） *&#x2F;</span><br><span class="line">@property(nonatomic, copy) NSString *miniVersion;</span><br><span class="line"></span><br><span class="line">&#x2F;*! 是否是全量包 仅给本地使用 *&#x2F;</span><br><span class="line">@property(nonatomic, assign) BOOL isBuild;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 以下3类都可以作为过滤不必要请求缓存的接口：若都为空，表示不设置过滤，所有的请求都缓存，设置了之后，仅对在白名单里或符合UA的请求进行缓存</span><br><span class="line">@property (nonatomic, strong) NSArray *whiteListsHost;       &#x2F;&#x2F;域名白名单</span><br><span class="line">@property (nonatomic, strong) NSArray *whiteListsRequestUrl; &#x2F;&#x2F;请求地址白名单</span><br><span class="line">@property (nonatomic, strong) NSString *whiteUserAgent;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>最后一步是客户端对webview的资源的拦截替换成本地的包，这里的方案很多，单独来讲</li>
</ul>
<h4 id="webview的资源拦截"><a href="#webview的资源拦截" class="headerlink" title="webview的资源拦截"></a>webview的资源拦截</h4><p>由于已经是2021年了，所以就完全不考虑UIWebView了，而且关于这部分的方案我和安卓都是共同去查，然后求同存异，最后得出的结果不能说毫不相干吧，只能说是一模一样。其实市面上的方案大体都是这几个，我这边尝试过其中的两种。</p>
<ul>
<li><p><strong>获取沙盒html路径直接通过file协议加载index.html</strong></p>
<p>通过方法加载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (nullable WKNavigation *)loadFileURL:(NSURL *)URL allowingReadAccessToURL:(NSURL *)readAccessURL API_AVAILABLE(macos(10.11), ios(9.0));</span><br></pre></td></tr></table></figure>

<p>用这个方案最大的好处是客户端简单，但是缺点也很多，因为我们之前组内其他同事就做过类似的方案，出现过跨域问题、file协议的接口问题。还有最重要的h5的改动的问题，我们一个很轻量边缘的h5页面就花了一个h5同事一个月的工作量</p>
</li>
<li><p><strong>使用NSURLProtocol拦截</strong>(尝试过的方案)</p>
<p>这个方案最初尝试的就是这个方案，直接注册整个urlprotocol，对请求进行拦截，但是在上线的前半个月出的一些问题我觉得还是把这个方案下了。</p>
<p>其中遇到过一些问题我分为可解决和不能解决的两种：</p>
<blockquote>
<p><em>可解决</em> ：1、 wkwebview的api不能使用的问题，这个可以通过hook解决</p>
<p>​                 2、 私有api的问题，可以通过混淆解决</p>
<p>未解决 ： post请求丢body的问题，在网上看过一系列的方案，包括不限于”让h5把body放在header里”， 以及“hook ajax”，但是都不能完美解决这个问题，而且只要注册了urlprotocol，哪怕不拦也不能解决。</p>
</blockquote>
<p>但是放弃这个方案还有一个重大的原因就是影响面太大了，只要注册一下，所以的请求原生的,webview的都会经过protocol走一道，完全无法做到颗粒度的细化，只要稍微出了点问题，都是大问题</p>
</li>
<li><p><strong>WKURLSchemeHandler</strong> (最终选用的方案)</p>
<p>这个方案同样也有缺点，不能拦截http,https诸如此类非自定义的请求。api兼容最低11，但是其实11之后的部分系统也有一些问题，完美应用是12。但是我们做了一些用户数据的分析(12以下的用户只占比3.4%)之后我们还是决定用这个方案。</p>
</li>
<li><p><strong>起本地服务器加载离线资源</strong></p>
<p>一个比较高大上的方案，并且涉及知识点比较多。我没去试这个方案是因为我自我认知上觉得对服务器方面的知识储备不够，出了问题我解决不了。但是国内外的大厂是有用这个方案的</p>
</li>
</ul>
<h4 id="WKURLSchemeHandler的实践"><a href="#WKURLSchemeHandler的实践" class="headerlink" title="WKURLSchemeHandler的实践"></a>WKURLSchemeHandler的实践</h4><p>关于这块我们开始是想了两个细化方案</p>
<ol>
<li>是让h5那边修改scheme，我们用自定义的shcheme进行注册拦截，这是我们这边预期最好的方案。因为细粒度能掌握到文件级，非常的稳定，容错高，但是代价是h5的同事要做更改。</li>
<li>直接通过私有api让<em>WKURLSchemeHandler</em>可以支持https和http，因为系统也是实现了这个方法然后来判断注册的shcheme来抛出异常，直接对这个函数进行overwrite就ok。但是如果这么做的话，只要对webview进行注册的所有的请求都会拦截。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)handlesURLScheme:(<span class="built_in">NSString</span> *)urlScheme</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后因为我们h5的同事时间紧，所以我们进行了第二种方式的处理，我对代码做了一些脱敏处理，写了些伪代码，大概是这样</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView startURLSchemeTask:(<span class="keyword">id</span> &lt;<span class="built_in">WKURLSchemeTask</span>&gt;)urlSchemeTask  API_AVAILABLE(ios(<span class="number">11.0</span>))&#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [urlSchemeTask request];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutaRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    [mutaRequest setValue:[<span class="keyword">self</span> getRequestCookieHeaderForURL:request.URL] forHTTPHeaderField:<span class="string">@"Cookie"</span>];</span><br><span class="line">    request = [mutaRequest <span class="keyword">copy</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> shouldCache = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (request.HTTPMethod &amp;&amp; ![request.HTTPMethod.uppercaseString isEqualToString:<span class="string">@"GET"</span>]) &#123;</span><br><span class="line">        shouldCache = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *hasAjax = [request valueForHTTPHeaderField:<span class="string">@"X-Requested-With"</span>];</span><br><span class="line">    <span class="keyword">if</span> (hasAjax != <span class="literal">nil</span>) &#123;</span><br><span class="line">        shouldCache = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.loadQueue, ^&#123;</span><br><span class="line">      <span class="comment">// 去本地根据url匹配本地文件</span></span><br><span class="line">        WebOfflineCacheItem *item = [WebOfflineCacheItem loadCompatibleItemWithRequest:request];</span><br><span class="line">        <span class="comment">// 有缓存</span></span><br><span class="line">        <span class="keyword">if</span> (item &amp;&amp; shouldCache &amp;&amp; item.MIMEType) &#123;</span><br><span class="line">            [urlSchemeTask didReceiveResponse:item.response];</span><br><span class="line">            <span class="keyword">if</span> (item.data) &#123;</span><br><span class="line">                [urlSchemeTask didReceiveData:item.data];</span><br><span class="line">                  <span class="comment">// 在这里可以做一些命中率的统计</span></span><br><span class="line">            &#125;</span><br><span class="line">            [urlSchemeTask didFinish];</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="comment">// 没有缓存，通过urlsession把请求发出去，然后和上面一样的方式还给urlSchemeTask</span></span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WKURLSchemeHandler的一些注意点"><a href="#WKURLSchemeHandler的一些注意点" class="headerlink" title="WKURLSchemeHandler的一些注意点"></a>WKURLSchemeHandler的一些注意点</h4><p>在测试以及上线后我们发现了一些问题，也做了一些相应的调整，大概如下</p>
<ul>
<li><p>本地未命中通过网络请求发出的task在webview提前关闭然后返回用urlschemeTask做接收引起的崩溃。</p>
<p> 可以通过在webview的代理中做一个记录，然后在urlSchemeTask接收数据的时候拿这个记录看下是否关闭做对应的处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView stopURLSchemeTask:(id &lt;WKURLSchemeTask&gt;)urlSchemeTask</span><br><span class="line">API_AVAILABLE(ios(11.0))&#123;</span><br><span class="line"></span><br><span class="line">    self.holdUrlSchemeTasks[urlSchemeTask.description] &#x3D; @(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>由于我们所有的webview用的同一个类，所以导致应用中的所有webview都会走这样的拦截，会导致不太可控，我的做法是在后台配置url的白名单，然后在注册的时候判断url来做对应的注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ([WebOfflineManager.shareInstance canActivaOfflineWithUrl:self.urlString]) &#123;</span><br><span class="line">           [configuration ssRegisterURLProtocol];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有前面说的这个api的11 available，但是我的建议是12起，其实根据苹果的官方信息11的留存用户真的不多，也可以根据自己的用户数据做调整，这只是我的建议</p>
</li>
<li><p>这样拦截会导致webview这部分的缓存失效，所以需要自己做webview的一个二级缓存实现，这个参考sd等开源库就好</p>
</li>
</ul>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>其实到最后，客户端两边的方案几乎是一致的，而且安卓那边做起来更加简单，可以直接把拦截不了的请求丢回给webview处理。另外根据后续的数据分析统计，我们首次加载的缓存提速大概在15-20左右，最终启动速度在1秒左右。关于这个统计和分析我这边是做了一个自动化的处理，后面有机会再写一篇</p>
]]></content>
      <categories>
        <category>工作总结</category>
      </categories>
  </entry>
  <entry>
    <title>isa详解</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/isa%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在之前类的本质的时候说过，结构体中有一个成员变量isa,在arm64之前他是一个指针，指向了他的类对象。用来访问函数之类的作用。但是arm64之后类的地址需要通过isa与一个值来做一个位运算。按理说arm64比之前更加先进，为什么要这么处理呢</p>
<h4 id="共用体-union-和位域"><a href="#共用体-union-和位域" class="headerlink" title="共用体(union)和位域"></a>共用体(union)和位域</h4><p>首先，要说的是，arm64之后的isa是优化过了的。可能会很纳闷，用起来比之前更麻烦了，为什么叫做优化了的。先让我们抛开这个问题，来想另外一个问题。我们知道BOOL类型占一个字节，每在一个类中定一个BOOL类型，都会额外消耗一个字节。一个字节有8位，其实BOOL就是1和0,完全可以直接用其中的任意1位来表示，就算去除符号位。之前装一个BOOL类型的现在可以装7个。大概的操作是这样</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOL1Mask (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOL2Mask (1&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOL3someMask (1&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOL4Mask (1&lt;&lt;3)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> bits;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> bool1 : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> bool2 : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> bool3 : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> bool4 : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; _boolCollection;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setBool1:(<span class="built_in">BOOL</span>)bool1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bool1) &#123;</span><br><span class="line">        _boolCollection.bits |= BOOL1Mask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _boolCollection.bits &amp;= ~BOOL1Mask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isBool1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !!(_boolCollection.bits &amp; BOOL1Mask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>首先我们定义了一个共用体/联合体(union)，所以内部里的1个字节的bits和结构体公用1个字节。然后_tallRichHandsome用了位域，例如tall用第0位以此内推。每次存取都是对bits操作，通过bits和对应的mask做位运算，用来设置对应的位和取出对应的位来处理。本质来说，其实有没有内部的结构体并没有影响，起了一个注释的作用。本质其实操作的是公用的一个字节中的几位。</p>
<p>其中上图中mask就是代表的是掩码，上面的掩码都是1位的，如果我们需要存放或取出多位，对应的掩码进行改变就好。</p>
<p>很明显我们利用了这种方式，在有限的内存空间下放了更多东西，而isa也是这样处理的</p>
<h4 id="isa"><a href="#isa" class="headerlink" title="isa"></a>isa</h4><p>isa是一个<em>isa_t</em> 类型的成员变量，查看<em>isa_t</em>,部门关键代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_PACKED_ISA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// extra_rc must be the MSB-most field (so it matches carry/overflow flags)</span></span><br><span class="line">    <span class="comment">// nonpointer must be the LSB (fixme or get rid of it)</span></span><br><span class="line">    <span class="comment">// shiftcls must occupy the same bits that a real class pointer would</span></span><br><span class="line">    <span class="comment">// bits + RC_ONE is equivalent to extra_rc + 1</span></span><br><span class="line">    <span class="comment">// RC_HALF is the high bit of extra_rc (i.e. half of its range)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// future expansion:</span></span><br><span class="line">    <span class="comment">// uintptr_t fast_rr : 1;     // no r/r overrides</span></span><br><span class="line">    <span class="comment">// uintptr_t lock : 2;        // lock for atomic property, @synch</span></span><br><span class="line">    <span class="comment">// uintptr_t extraBytes : 1;  // allocated with extra bytes</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中uintptr_t 是unsigned long 的typedef,所以是8个字节，一共64位，可以看到结构体中所有位域加起来刚好64位。那么其中这些位都表示的是什么呢?</p>
<blockquote>
<ul>
<li>nonpointer<ol>
<li>0，代表普通的指针，存储着Class、Meta-Class对象的内存地址</li>
<li>1，代表优化过，使用位域存储更多的信息</li>
</ol>
</li>
<li>has_assoc  是否有设置过关联对象，如果没有，释放时会更快</li>
<li>has_cxx_dtor 是否有C++的析构函数（.cxx_destruct），如果没有，释放时会更快</li>
<li>shiftcls   存储着Class、Meta-Class对象的内存地址信息</li>
<li>magic   用于在调试时分辨对象是否未完成初始化</li>
<li>weakly_referenced  是否有被弱引用指向过，如果没有，释放时会更快</li>
<li>deallocating  对象是否正在释放</li>
<li>extra_rc  里面存储的值是引用计数器减1</li>
<li>has_sidetable_rc<ol>
<li>引用计数器是否过大无法存储在isa中</li>
<li>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</li>
</ol>
</li>
</ul>
</blockquote>
<p>先说说这些会释放过快是怎么得出来的，首先文档有写。其次源码也有，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory. </span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Calls ARC ivar cleanup.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有这些关联数据的时候需要去清除</p>
<h4 id="isa-t的验证"><a href="#isa-t的验证" class="headerlink" title="isa_t的验证"></a><em>isa_t</em>的验证</h4><p>接下来，对上面进行一个验证。写下如下示例代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! person  */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *p1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Person *p2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.p1 = p;</span><br><span class="line">    <span class="keyword">self</span>.p2 = p;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(p) weakP = p;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>打印isa如下</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/isa%E8%AF%A6%E8%A7%A3/isa%E8%AF%A6%E8%A7%A31.png" alt="isa详解"></p>
<p>展开成二进制</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/isa%E8%AF%A6%E8%A7%A3/isa%E8%AF%A6%E8%A7%A32.png" alt="isa详解"></p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/isa%E8%AF%A6%E8%A7%A3/isa%E8%AF%A6%E8%A7%A33.png" alt="isa详解"></p>
<blockquote>
<ul>
<li><p>第一位nonpointer为1，代表优化过，存储了更多信息</p>
</li>
<li><p>第二位 has_assoc为0，我们的确没有添加关联对象</p>
</li>
<li><p>第三位 has_cxx_dtor，也的确没有c++析构函数</p>
</li>
<li><p>中间33位 000100000010111011010101011101010,补全3位0，转成16进制为0x102ed5750,通过图片2种打印验证都没错</p>
<p> <img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/isa%E8%AF%A6%E8%A7%A3/isa%E8%AF%A6%E8%A7%A34.png" alt="isa详解"></p>
</li>
<li><p>再左移6位magic，011010，补全0，结果为0x000001a000000001，这块没有找到更详细的资料，只知道用于在调试时分辨对象是否未完成初始化，在arm64中0x16是调试器判断当前对象是真的对象还是没有初始化的空间。</p>
</li>
<li><p>再左移一位，weakly_referenced， 是否有被弱饮用引用过，确实是1，我们代码也的确有一个弱引用。</p>
</li>
<li><p>再左移一位，deallocating，对象是否正在释放为0，只有执行完这个代码块才会被释放。没有问题</p>
</li>
<li><p>再左移一位，has_sidetable_rc，为0，引用计算没有大到需要存到sideTable中</p>
</li>
<li><p>最后19位，extra_rc，引用计算位，二进制10，则为2,引用计数则为3。代码中有一个局部变量2个成员变量应用，确实为3</p>
</li>
</ul>
</blockquote>
<p>整体验证完毕，确实如预期一样，而且我们也知道了所有类的地址都是8位对齐的。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>总体，我们知道了为什么需要优化isa,以及优化之后的效果，并且进行了验证。</p>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>jenkins镜像更新</title>
    <url>/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/jenkins%E9%95%9C%E5%83%8F%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在给测试配一台新的打包节点，顺便也更新下自己本机的脚本。然后发现很久以前的jenkins的版本和一些装好的插件都提示过期，为了方便使用就用到<em>updateCenter</em> 中自动更新，然后更新一直失败。所以只能换源，但是在网上查的换源方法都多多少少有点不对，或者都是copy ninja。所以自己总结一下</p>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><ul>
<li><p>首先在插件管理的高级中将源更改为目标源，例如<em><a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></em>，但是光做这个并没有什么用。这个只是把每次获取default.json这个文件的来源换了。但是具体的插件更新还是依赖于default.json内部的链接，但是内部的链接指向还是原来的地址。</p>
</li>
<li><p>编辑update.json:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找到updates文件夹内部的default.json进行替换</span></span><br><span class="line">cd .jenkins/updates/</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用sed命令进行新老源的替换,这是老版本的替换命令，具体来说就是将updates.jenkins-ci.org替换为mirrors.tuna.tsinghua.edu.cn，www.google.com替换为www.baidu.com：</span></span><br><span class="line"></span><br><span class="line">sed -i '' 's#http://updates.jenkins-ci.org/download#https://mirrors.tuna.tsinghua.edu.cn/jenkins#g' default.json &amp;&amp; sed -i '' 's#http://www.google.com#https://www.baidu.com#g' default.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 老版本的本源和新版本地址不一样，可以自己在文件内搜索是老版本还是新版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然，在最新的jenkins版本中，已经有了调整，配置文件中的地址不再是updates.jenkins-ci.org，所以命令也需要实时更新：</span></span><br><span class="line">sed -i '' 's#https://updates.jenkins.io/download#https://mirrors.tuna.tsinghua.edu.cn/jenkins#g' default.json &amp;&amp; sed -i '' 's#http://www.google.com#https://www.baidu.com#g' default.json</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="sed注意点"><a href="#sed注意点" class="headerlink" title="sed注意点"></a>sed注意点</h4><ul>
<li><p><strong><em>问题</em></strong></p>
<p>由于我是在mac平台，在最开始用sed命令的时候发现有一些不对，上面的指令是已经改过的。假如用下面这条在linux上运行无误的指令则会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i 's#http://updates.jenkins-ci.org/download#https://mirrors.tuna.tsinghua.edu.cn/jenkins#g' default.json &amp;&amp; sed -i '' 's#http://www.google.com#https://www.baidu.com#g' default.json</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/jenkins%E9%95%9C%E5%83%8F%E6%9B%B4%E6%96%B0/jenkins%E9%95%9C%E5%83%8F%E6%9B%B4%E6%96%B01.png" alt="jenkins镜像更新"></p>
<ul>
<li><p><strong><em>原因</em></strong></p>
<p>执行man sed查看帮助，发现 -i 操作后面要跟一个extension参数，明确备份的文件</p>
</li>
</ul>
<p><img src="/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/jenkins%E9%95%9C%E5%83%8F%E6%9B%B4%E6%96%B0/jenkins%E9%95%9C%E5%83%8F%E6%9B%B4%E6%96%B02.png" alt="jenkins镜像更新"></p>
<ul>
<li><p><strong><em>解决</em></strong></p>
<p>我们不需要备份文件，所以给个长度为0的参数就好了，即 -i 后面追加一个’’,如第实践中的正确指令</p>
</li>
</ul>
]]></content>
      <categories>
        <category>工作总结</category>
      </categories>
  </entry>
  <entry>
    <title>lightRoom的简单使用</title>
    <url>/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>之前在刚接触拍照的时候，由于自己的无能和懒惰，所以特别强调直出，觉得后期不重要。在对摄影这件事的了解逐步加深之后，发现好的照片或多或少都会进行后期。好的后期会让照片更加具有艺术色彩和表现的张力。为了提高成片率以及自己的摄影能力，所以决定好好学学后期，后期的软件很多，还是决定和学其他东西的思路一样。先找一个代表性的玩熟练，再以点到面。最后决定先从lightroom开始</p>
<h4 id="Lightroom简介"><a href="#Lightroom简介" class="headerlink" title="Lightroom简介"></a>Lightroom简介</h4><p>可能提起修图第一反应都是PS。PS是adobe出的一款图片处理工具，而lightroom也是出自于adobe。LR由Adobe发布于2007年。但是不同的是PS更多针对的是出版业，LR更加面向数码摄影。LR整体分为4个模块:图库、修改照片、幻灯片放映、打印。后面2个基本不怎么用</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A81.png" alt="lightRoom的简单使用"></p>
<h4 id="图库"><a href="#图库" class="headerlink" title="图库"></a>图库</h4><p>图库可以理解为我们的相册的功能，提供了最基本的照片导入和管理的功能。</p>
<h6 id="导入："><a href="#导入：" class="headerlink" title="导入："></a>导入：</h6><p>​       可以直接在把图片往整个窗口拖动到软件窗口中，也可以点击图库—&gt;导入进行批量导入</p>
<h6 id="导出"><a href="#导出" class="headerlink" title="导出:"></a>导出:</h6><p>​      在图片后期处理完成之后可以点击图库—&gt;导出进行导出。甚至可以做一些导出的后置处理，例如水印、压缩等等。例如如果发朋友圈可以提前把长边压缩到1080以下，避免微信压缩效果变差。</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A82.png" alt="lightRoom的简单使用"></p>
<h6 id="图片管理"><a href="#图片管理" class="headerlink" title="图片管理:"></a>图片管理:</h6><p>​      在图库中，你还可以对图片进行批量管理、例如设置旗标、打星、以及设置关键字等等。方便我们后续筛选和排查，可以简单理解为提前对图片打上一些关键信息，然后后续通过SQL对图片批量分类管理。方便我们对统一风格的图片进行批量处理。</p>
<h4 id="修改照片"><a href="#修改照片" class="headerlink" title="修改照片"></a>修改照片</h4><p>修改照片模块给了我们各种方式去修改图片中各种参数，如图。</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A83.png" alt="lightRoom的简单使用"></p>
<p>当然、我们修图肯定不是按照这个顺序从上到下来一遍，而是要拥有自己的修图思路。在拿到图要想到这张图要表达的是什么。决定修图的大体方向。决定方向之后可以根据下面的整体思绪来修图</p>
<p><strong><em>修正物理错误</em></strong></p>
<ul>
<li><h6 id="基本的透视矫正"><a href="#基本的透视矫正" class="headerlink" title="基本的透视矫正"></a>基本的透视矫正</h6></li>
</ul>
<hr>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A84.png" alt="lightRoom的简单使用"></p>
<p>如上图，所有的平面都会汇聚到最终的1点或者2点，这叫2点透视。当出现3点透视时，建筑或者拍摄的物体会给人一种倾斜的感觉</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A85.png" alt="lightRoom的简单使用"></p>
<p>例如左图，最终在图的最上方也会相交成一个点。会让这栋建筑看起来像个尖塔、而失去了宏伟的感觉。而且”横平竖直与对称是美术生的基本功”。出现这种问题可以直接在修改照片—&gt;变换中进行修正</p>
<ul>
<li><h6 id="紫边修正"><a href="#紫边修正" class="headerlink" title="紫边修正"></a>紫边修正</h6></li>
</ul>
<p>紫边是指数码相机在拍摄过程中，由于被摄物体反差较大．在照片上亮部与暗部交界处出现的色散现象，沿交界处会出现一道紫色的镶边(多数情况下是紫色，有时也可能是其他颜色)，这种现象就叫做紫边现象。</p>
<p>虽然好的镜头都会处理好这个问题，但是如果产生了用LR去修复是很简单的事情。</p>
<p>可以直接在修改照片—&gt;镜头矫正中进行修正</p>
<p><strong><em>污点去除</em></strong></p>
<p>如果照片中我们不想要的东西可以进行去除可以使用污点去除工具进行去除</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A86.png" alt="lightRoom的简单使用"></p>
<p><em>仿制</em>就是<em>修复</em>瑕疵的时候用选定的素材在瑕疵上面一层一层地盖,<em>修复</em>就是用选定的素材去替换瑕疵区域并且与周围的素材进行一定的融合。推荐使用修复</p>
<p><strong><em>整体处理</em></strong></p>
<ul>
<li><h6 id="整体曝光"><a href="#整体曝光" class="headerlink" title="整体曝光"></a>整体曝光</h6><p>整体曝光指的是整个画面过暗或者过量时，对画面亮度进行的一些处理。</p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A87.png" alt="lightRoom的简单使用"></p>
<p>  当对曝光进行拉动时，会影响到整个画面。但是我们一般不会这么做，影响太大。一般都是对<strong>高光</strong>和<strong>阴影</strong>进行操作</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A88.png" alt="lightRoom的简单使用"></p>
<p>  整幅画中，我们可以把所有的明亮度的像素点标注出来大概就是如图。如果我们把他们按照明亮等级进行整理并且排列，会构成一幅类似下面的图</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A89.png" alt="lightRoom的简单使用"></p>
<p>  图中可以分为最暗最亮，还有比较暗，和比较亮的地方。其中比较暗的地方就是阴影，比较亮的就是高光。上面的调整高光和阴影就是对比较亮和比较暗的地方进行曝光处理。</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A810.png" alt="lightRoom的简单使用"></p>
<p>  另外也可以通过曲线来操作高光和阴影。</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A811.png" alt="lightRoom的简单使用"></p>
<p>  这就是压低高光，拉高阴影</p>
<h6 id="色温色调"><a href="#色温色调" class="headerlink" title="色温色调"></a>色温色调</h6><p>  “色温指的是整体上给人的饱满温和还是单调冷艳,而色调是一幅作品色彩外观的某种倾向,更强调倾向。</p>
<p>  在上图中拉动色温色调滑块就是对其进行调整</p>
<h6 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h6><p>  饱和度(Saturation)指的是色彩纯度。是色彩的构成要素之一。纯度越高，表现越鲜明，纯度较低，表现则较 黯淡。例如我们可以先选取到树叶的饱和度，然后进行拉到。让叶子更绿….</p>
<p>  如图，可以用hsl工具选中某个颜色去调对应的色相、饱和度、明亮度。</p>
<p>  也可以用颜色分级来分别调高光和阴影，先选中高光或者阴影，然后选中对应的颜色倾向。再去选择倾向程度。</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A812.png" alt="lightRoom的简单使用"></p>
<p>  三原色调整，一般只拉低蓝原色的色相、会让整个画面的颜色类别变小、显得更加高级</p>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A813.png" alt="lightRoom的简单使用"></p>
<h6 id="清晰度"><a href="#清晰度" class="headerlink" title="清晰度"></a>清晰度</h6><p>   让画面更加清晰，不那么脏</p>
<h6 id="黑白色阶"><a href="#黑白色阶" class="headerlink" title="黑白色阶"></a>黑白色阶</h6><p>  让画面中的黑色和白色更纯 </p>
<p><strong><em>局部处理</em></strong></p>
<ul>
<li><h6 id="渐变滤镜"><a href="#渐变滤镜" class="headerlink" title="渐变滤镜"></a>渐变滤镜</h6></li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A814.png" alt="lightRoom的简单使用"></p>
<p>  可以点击框出一片渐变区域，按住shift会让渐变选中的区域变得规整。然后可以调整对应的参数来改变渐变区域</p>
<ul>
<li><h6 id="径向滤镜"><a href="#径向滤镜" class="headerlink" title="径向滤镜"></a>径向滤镜</h6></li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A815.png" alt="lightRoom的简单使用"></p>
<p>  可以自定义一片区域(例如脸部)来做处理，点击选中后，选中反向。然后调整参数进行更改</p>
<p><strong><em>降噪和锐化</em></strong></p>
<ul>
<li><h6 id="锐化"><a href="#锐化" class="headerlink" title="锐化"></a>锐化</h6><p> 本质就是增加局部的对比度，通过让黑面产生更黑的黑边，白面产生更白的白边。以此来突出反差</p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A816.png" alt="lightRoom的简单使用"></p>
<p>  数量代表锐化的强度</p>
<p>  按住alt滑动蒙版，可以控制被锐化的模块</p>
<p>  半径: 调整的“局部”有多大(边界添加黑边的宽度)</p>
<p>  细节: 哪些东西被锐化了（阈值）</p>
<ul>
<li><h6 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h6></li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/lightRoom%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A817.png" alt="lightRoom的简单使用"></p>
<p>​    滑动拉高颜色去除颜色燥点,滑动明亮度会去除明亮度燥点。明亮度不宜拉的太高，会让画面失去锐度</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>这篇基本就是对LR的使用做了一个简单的笔记，基本都是用于宏观的调控，色彩亮度等等…至于我还想学的还有人脸的后期、美化等等。但是可能这部分会用到ps,边走边看吧</p>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
  </entry>
  <entry>
    <title>photoshop的简单使用</title>
    <url>/%E6%91%84%E5%BD%B1/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>之前有用Lightroom来做一些简单的图片后期，但是有一些功能是是LR做不到的，例如抠图，对抠图的部分做操作。而且也有部分功能是都能做但是ps能做得更好的，例如污点去除，所以还是很有必要好好学一下ps</p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul>
<li><p><strong><em>背景都弄成白色</em></strong></p>
<p><img src="/%E6%91%84%E5%BD%B1/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A81.png" alt="photoshop的简单使用"></p>
<p>添加色相饱和度图层，自带一个蒙版，将饱和度调低至0，整体都是灰色，然后利用画笔工具将需要显示彩色的部分涂抹出来。如果需要反转直接按command + L</p>
</li>
<li><p><strong><em>抠图工具</em></strong>:假如如下图人物太黑，背景已经足够亮了，只需要处理人物。可以利用左侧选择对象选择工具将人物扣出来单独做处理，例如需要加亮度，就选择一个曲线图层，会自带一个蒙版。然后拉高对应的亮度，如果裤子不需要提亮，可以用画笔工具选择黑色，然后涂抹掉裤子部位。假如觉得亮度不够 Command + j 复制蒙版涂层</p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A82.png" alt="photoshop的简单使用"></p>
<ul>
<li><strong><em>抠图加蒙版的使用2</em></strong>:  例如下图想营造一下电影里的感觉，可以通过降低背景的色相饱和度，然后增强人物的亮度来做处理。首先通过对象选择工具慢慢把人物扣出来，然后选择一个一个自然饱和度的图层，然后拉低饱和度。但是这个时候操作的是扣出来的人物，可以通过command+i进行蒙版反选，操作的就是整个背景了。然后合并图层，选择camera raw滤镜，选择颜色分级，把阴影部分往黄绿色调。然后用裁剪工具进行裁剪</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A83.png" alt="photoshop的简单使用"></p>
<ul>
<li><p><strong><em>色阶+阈值+黑白场</em></strong>：  例如下图中，选择色阶图层，会出现类似一个直方图，其中2个峰值大概横向坐标大概指向30和220左右，其实就是下图中对应的字和背景。但是不是纯黑和纯白。我们可以通过设置黑白场来做到想要的效果，分别用设置黑场的墨水笔去选中字体部分、用白场选择背景部分。就可以区分开了。也可以通过推动直方图中的黑白中间场3个标记来做到这件事。</p>
<p> 也可以通过阈值蒙版来做这件事，做得更好，滑动阈值、达到自己想要的结果</p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A84.png" alt="photoshop的简单使用"></p>
<p><img src="/%E6%91%84%E5%BD%B1/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A85.png" alt="photoshop的简单使用"></p>
<ul>
<li><p><strong><em>扣头发丝</em></strong>： 利用选择对象工具，然后点击选择并遮住，然后在右侧菜单栏点击视图选项，选择一个比较好区分的方式，例如叠加，然后先把大体轮廓选择出来。在最后选择头发丝细节的时候在左侧菜单选择<strong>调整边缘画笔工具</strong>，弄完之后选择输出到：新建带有图层蒙版的图层。 这个时候如果图片不够锐利的话头发就会出现白丝，这个时候就要去修复白丝</p>
<p>利用<strong>剪切蒙版法</strong>，在刚才已经抠出来的头发丝的基础上。新建蒙版，右键创建剪切蒙版.然后利用吸管工具(option + 左键)吸取白色周围正常头发的发色，然后利用画笔来涂抹.如果觉得颜色不对也可以利用橡皮工具进行擦除。然后改变画笔的硬度和大小来调头发丝的细节</p>
</li>
<li><p><strong><em>通道法抠图</em></strong>: 适合扣半透明复杂的场景，例如下图中的扣树。选择通道，在三个通道中选择一个更加能够把树和天空区分开来的通道，然后复制该通道，然后对该通道进行操作，选择图像菜单-&gt;调整-&gt;色阶。然后利用上面色阶的知识，推动黑白场，来彻底区分开两者。分开后利用command+左键点击拷贝通道建立选区。然后回到图层中利用这个选区直接创建蒙版。然后就可以了。可以新建一个蒙版作为背景，然后按住option+delete来填充颜色看是否有抠好</p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A86.png" alt="photoshop的简单使用"></p>
<ul>
<li><strong><em>画笔工具</em></strong>: 画笔不仅仅可以简单拿来做涂抹，也可以利用画笔工具对图片进行内容补充，例如上图中的树木。我们可以利用飞鸟画笔在树中添加各种各样的鸟。需要什么样的画笔就去找对应的素材即可，例如雪花等等……然后利用画笔细节设置做出各种渐变、自然的景象。最后如果觉得不真实可以将对应的笔刷蒙版更改透明度、或者转换为智能对象然后在滤镜中做高斯模糊的效果(雪景)</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/photoshop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A87.png" alt="photoshop的简单使用"></p>
<ul>
<li><p><strong><em>图片合成</em></strong>: 文件-&gt;自动-&gt;photo merge, 适合用于我们一个画面拍不下，需要多张图连起来的时候的场景。当我们横向画面不够时，我们拍摄时最好用竖构图来拍。反之如果想竖直叠加就用横构图，因为这样的画面会更广</p>
</li>
<li><p><strong><em>给画面增加光晕</em></strong>: 滤镜-&gt;redgridentsofware-&gt;插件 做调整</p>
</li>
</ul>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>总体来说，PS相对于LR来说更加专业，毕竟LR大部分功能在PS的camera raw滤镜中都有。所以就需要更多的储备知识，其实学了一段时间之后才发现这些都是工具，后期需要更多的是思路和审美。以后还是要多看图和景提高自己的储备。不然有工具也不知道怎么用</p>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
  </entry>
  <entry>
    <title>swiftMonkey的实践</title>
    <url>/swift/swiftMonkey%E7%9A%84%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在了解到monkey测试之后，觉得这个东西的确比较有必要，用起来成本太低了，只需要配置好点击一下，然后就可以让他模拟用户的行为。对于拿来做上线前的压力测试，获取一些crash是很有必要的。尽管并不一定能测出来。但是还是那句话，成本太低了，一台电脑，一部手机就可以拥有一个免费劳工</p>
<h3 id="预研"><a href="#预研" class="headerlink" title="预研"></a>预研</h3><p>作为一个普通开发工程师，之前对这方面几乎一片空白,只知道android那边有现成的，所以先去调查了一下。发现了有3个可选的技术</p>
<ul>
<li><a href="https://testerhome.com/topics/2718" target="_blank" rel="noopener"><strong>CrashMonkey</strong></a>  后面发现不支持新版本Xcode，所以不可选</li>
<li><a href="https://testerhome.com/topics/9810" target="_blank" rel="noopener"><strong>Fastmonkey</strong></a> 这个很厉害，配合别人的<a href="https://github.com/Lemonzhulixin/iOS-monkey" target="_blank" rel="noopener">二次开发</a>，功能特别强大，但是也只能支持低版本的Xcode,和别人交流可以在电脑装一个低版本的Xcode专门来跑monkey，但是可能由于我的系统版本的问题老是崩溃，所以暂时放下。但是这个肯定要回来再看的</li>
<li><a href="https://github.com/zalando/SwiftMonkey" target="_blank" rel="noopener"><strong>SwiftMonkey</strong></a> 一款XCUITesting框架开发的app稳定性测试工具，除了性能没有FastMonkey那么快，好像也还行。于是就决定用这个</li>
</ul>
<h3 id="SwiftMoneky"><a href="#SwiftMoneky" class="headerlink" title="SwiftMoneky"></a><a href="https://github.com/Lemonzhulixin/iOS-monkey" target="_blank" rel="noopener">SwiftMoneky</a></h3><ul>
<li><p><strong>SDK接入</strong>： 接入特别简单，直接手动拖拽和pods，我用的手动拖拽，一共2个project对应两个framework，swiftmonkey是拿来做测试的，monkeypaws是一个图形化的工具，用来展示具体的运动轨迹的</p>
</li>
<li><p><strong>OC项目</strong>: 做好对应的桥接文件的配置，做好项目依赖。主项目依赖paws,新建的XCUITest依赖monkey。根据文档配置好代码跑起来就没问题</p>
</li>
<li><p><strong>自定义插桩</strong>：monkey是<u>支持自定义的事件的插桩</u>的,写好对应的代码，配置好间隔权重就可以。例如登录，有时候你并不想monkey一直在登录界面做一些无用功，就可以自定义一个登录的插桩。可以配合XCUITest的代码录制来一起做</p>
</li>
</ul>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    Add a block for fixed-interval events.</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">    - parameter interval: How often to generate this</span></span><br><span class="line"><span class="comment">      event. One of these events will be generated after</span></span><br><span class="line"><span class="comment">      this many randomised events have been generated.</span></span><br><span class="line"><span class="comment">    - parameter action: The block to run when this event</span></span><br><span class="line"><span class="comment">      is generated.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">addAction</span><span class="params">(interval: Int, action: @escaping ActionClosure)</span></span> &#123;</span><br><span class="line">    regularActions.append((interval: interval, action: actInForeground(action)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>但是对于一个工具来说，目前这样不太合格，需要开发人员去运行ide，去一直看着电脑跑，对测试更不友好。所以需要做一些自动化的事情。所以想到配合Jenkins新建一个job。</p>
<p>自己规划了一下计划，决定成品应该是这样的，需要测试的人应该只用输入需要跑的事件和测试代码的分支。然后就可以不用管，等待时间查看日志就行。所以job的大概执行思路是这样的</p>
<p><img src="/swift/swiftMonkey%E7%9A%84%E5%AE%9E%E8%B7%B5/setp.png" alt="setp"></p>
<p>但是按着这个思路做还是遇到了一些问题。</p>
<ul>
<li><p><strong>单次跑monkey的问题</strong>:  之前跑都是通过Xcode点击来跑的，但是在jenkins上要基于命令行，其实这个还是比较简单。xcode作为一个gui工具也是基与xcodebuild来做的这些。查了下xcodebuild的资料，其实运行测试只用加上test的参数就行。整个命令下来大概是这个样子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcodebuild test -workspace xx.xcworkspace -scheme xx -destination 'platform=xx,id=xx' -derivedDataPath xx</span><br></pre></td></tr></table></figure>

<p>其中platform可以选择iOS和iOS Simulator,id是设备id，也可以根据name来做检索</p>
</li>
</ul>
<ul>
<li><p><strong>获取设备信息的问题:</strong> 可以通过<a href="https://github.com/ios-control/ios-deploy" target="_blank" rel="noopener">ios-deploy</a>来做处理，通过<u>ios-deploy -c –no-wifi -j</u>获取json格式的数据，后续可以通过一些处理拿到id或者name，交给上一步去做处理。我是用ruby写了个简单的脚本。这个就不多说了</p>
</li>
<li><p><strong>循环跑的问题:</strong> 在单次用例失败过后，monekey会停下来，尽管你可以通过设置continueAfterFailure=true来做，但是并不推荐。找了下资料，当一条命令执行成功之后，才会继续走下一条命令。在第一步的命令后面加上||true ，就算这个monkey失败了，也标记为成功，然后写个循环就好了</p>
</li>
</ul>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>其实到这里，差不多就结束了，通过这段时间的了解，发现XCUITest特别强大，我们可以录制好一段自定的插桩，来做业务的自动化测试。也可以做性能测试，例如启动速度，cpu，内存，disk，这些都是自带的一些API。后续也会往这方面再查看一下</p>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title>__block修饰符</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8B%E5%88%92%E7%BA%BFblock%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在block日常使用中，部分情况下不可避免的要修改捕获的外部变量的值，这个时候编译器会直接报错。并且提示我们要在变量前加上__block修饰符。那么为什么要这么做呢，加上之后做了什么事呢</p>
<h4 id="block做了啥"><a href="#block做了啥" class="headerlink" title="__block做了啥"></a>__block做了啥</h4><p>首先我们定义一个demo如下，然后用clang编译成c++,这样有利于我们之前观察本质</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        __block <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">void</span>(^block2)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">            a = <span class="number">4</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        block2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_a_0), <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">void</span>(*block2)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们从上面发现a =2这个变量被包装成了一个<em>__Block_byref_a_0</em>类型的东西，并且通过一个函数来创建了他。首先我们看下这个类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_a_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到包装的这个类型也是个对象，并且其中包含了之前了定义的a,并且在初始化的时候传进来也是2。</p>
<p>在创建这个包装的对象的时候传递了4个参数，0传给了isa,将自己的地址传递了给了自己的<em>__forwarding</em>,0传给了<em>flag</em>,自己的大小传递给了<em>__size</em>，而将2也保存到了同名的a中。</p>
<p>而在block的自身结构体中也用同名的变量a来保存了这个包装后的结构体,然后再让我们看看对应函数的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// block内部的实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">            (a-&gt;__forwarding-&gt;a) = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// block的desc的2个内存管理函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>发现取值的时候也是通过block的a拿到包装的结构体，然后通过<em>__forwarding</em>指针拿到自身，因为这个时候自身可能已经在堆里了，然后再拿到a的变量做的对应操作。</p>
<p>而发现之前我们了解过的内存管理的函数也对对应的包装的对象结构体做了内存管理</p>
<p>所以我们可以总结成这个图</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8B%E5%88%92%E7%BA%BFblock%E4%BF%AE%E9%A5%B0%E7%AC%A6/block%E4%BF%AE%E9%A5%B0%E7%AC%A61.png" alt="下划线block修饰符"></p>
<h4 id="block修饰对象"><a href="#block修饰对象" class="headerlink" title="__block修饰对象"></a>__block修饰对象</h4><p>上面研究的都是基础数据类型，接下来我们看看对象</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">       __block Person *p = [[Person alloc] init];</span><br><span class="line">        <span class="keyword">void</span>(^block2)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">            p = [[Person alloc] init];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        block2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转译成c++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">       __attribute__((__blocks__(byref))) __Block_byref_p_0 p = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,   (__Block_byref_p_0 *)&amp;p, <span class="number">33554432</span>, <span class="keyword">sizeof</span>(__Block_byref_p_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)((Person *(*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)objc_getClass(<span class="string">"Person"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>))&#125;;</span><br><span class="line">        <span class="keyword">void</span>(*block2)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_p_0 *)&amp;p, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block2)-&gt;FuncPtr)((__block_impl *)block2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_p_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_p_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> Person *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>明显创建这个<em>__Block_byref_p_0</em>对象的构造方法复杂了很多，我们只关注与之前的不同点。多传了2个函数<em>_Block_byref_id_object_copy_131，</em><em>Block_byref_id_object_dispose_131</em>，最后一个参数是把p传了进去。看下对应的2个函数和实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_copy_131(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src) &#123;</span><br><span class="line"> _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_dispose_131(<span class="keyword">void</span> *src) &#123;</span><br><span class="line"> _Block_object_dispose(*(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本是上对一个基础地址的+40的地址做内存管理操作。其实这个就是在对<em>__Block_byref_p_0</em>内部的结构体变量做内存操作，例如上面的p,恰好偏移40的地址。所以这里就涉及了2层的内存管理，block自身对__block对象的管理，以及它自身对内部真正的同名捕获对象的管理</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所有通过__block来修饰的变量都会被包装成一个对象，只不过会根据修饰的数据类型是普通类型还是对象类型，来额外生成对应的内存管理函数</p>
<h6 id="block对变量的内存管理"><a href="#block对变量的内存管理" class="headerlink" title="block对变量的内存管理"></a>block对变量的内存管理</h6><ul>
<li><p>当block拷贝到堆上时，都会通过copy函数来处理捕获的对象类型变量，__block只是一种特殊的对象变量类型</p>
<ol>
<li><p>__block变量（假设变量名叫做a）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象类型的auto变量（假设变量名叫做p）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;p, (<span class="keyword">void</span>*)src-&gt;p, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>当block从堆上移除时，都会通过dispose函数来释放它们</p>
<ol>
<li><p>__block变量（假设变量名叫做a）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象类型的auto变量（假设变量名叫做p）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;p, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h6 id="block对捕获的变量的内存管理"><a href="#block对捕获的变量的内存管理" class="headerlink" title="__block对捕获的变量的内存管理"></a>__block对捕获的变量的内存管理</h6><ul>
<li>当__block变量被copy到堆时或者从堆中移除，如果是普通数据类型，并不需要做对内部的变量做任何内存管理</li>
<li>当__block变量被copy到堆时，如果是对象类型<ol>
<li>会调用__block变量内部的copy函数</li>
<li>copy函数内部会调用_Block_object_assign函数，然后根据对应的地址偏移找到捕获的变量</li>
<li>_Block_object_assign函数会根据所指向对象的修饰符（<strong>strong、</strong>weak、__unsafe_unretained）做出相应的操作，形成强引用（retain）或者弱引用（注意：这里仅限于ARC时会retain，MRC时不会retain）</li>
</ol>
</li>
<li>当__block变量从堆上移除，如果是对象类型<ol>
<li>会调用__block变量内部的dispose函数</li>
<li>dispose函数内部会调用_Block_object_dispose函数</li>
<li>_Block_object_dispose函数会自动释放指向的对象（release）</li>
</ol>
</li>
</ul>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>其实就是可以简单把__block变量理解为把捕获变量进行做了一层包裹的变量就行了。而且是同名，那么还有一点。当我们在加了修饰符之后访问这个变量到底是原来的那个变量，还是包裹的这个呢？直接打印一下就行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">       __block Person *p = [[Person alloc] init];</span><br><span class="line">        <span class="keyword">void</span>(^block2)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block被调用%@"</span>,p);</span><br><span class="line">            p = [[Person alloc] init];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"block变量生成%@"</span>,p);</span><br><span class="line">        block2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8B%E5%88%92%E7%BA%BFblock%E4%BF%AE%E9%A5%B0%E7%AC%A6/block%E4%BF%AE%E9%A5%B0%E7%AC%A62.png" alt="下划线block修饰符"></p>
<p>其实访问的还是Person类型，其实这很好理解，毕竟编译器还是面向的是普通开发者，并没有必要在开发的时候把这些问题弄得过于复杂化。</p>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树的最大宽度</title>
    <url>/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>最近在复习二叉树相关的知识，在力扣上看到<a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener">这道题</a>，觉得挺有意思的。看到就想肯定是要用层序遍历，但是最开始用了很笨的方法，性能果然有问题，后面看了一些相关的注解，觉得真的是妙不可言</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p><img src="/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A61.png" alt="二叉树的最大宽度"></p>
<p>当一棵树是满二叉树时，我们可以给每个对应的节点上索引，例如a根结点的索引为i,可以分别对他的左右节点赋值为2i和2i+1。例如上图中，a的索引就是1,B是2，c是3，而d和e作为b的节点，分别则为4和5.这样每个节点都有自己独一无二的索引。而且每一层的宽度，恰好是最右的节点的索引-最左的节点 + 1.</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>废话不多说直接上代码，由于个人主要擅长oc和swift，就拿swift来求解</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">TreeNode?</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">TreeNode?</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">init</span>() &#123; <span class="keyword">self</span>.val = <span class="number">0</span>; <span class="keyword">self</span>.<span class="keyword">left</span> = <span class="literal">nil</span>; <span class="keyword">self</span>.<span class="keyword">right</span> = <span class="literal">nil</span>; &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> val: <span class="type">Int</span>) &#123; <span class="keyword">self</span>.val = val; <span class="keyword">self</span>.<span class="keyword">left</span> = <span class="literal">nil</span>; <span class="keyword">self</span>.<span class="keyword">right</span> = <span class="literal">nil</span>; &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> val: <span class="type">Int</span>, <span class="number">_</span> <span class="keyword">left</span>: <span class="type">TreeNode?</span>, <span class="number">_</span> <span class="keyword">right</span>: <span class="type">TreeNode?</span>) &#123;</span><br><span class="line">         <span class="keyword">self</span>.val = val</span><br><span class="line">         <span class="keyword">self</span>.<span class="keyword">left</span> = <span class="keyword">left</span></span><br><span class="line">         <span class="keyword">self</span>.<span class="keyword">right</span> = <span class="keyword">right</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">widthOfBinaryTree</span><span class="params">(<span class="number">_</span> root: TreeNode?)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> root = root <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个栈保存元组，0代表节点，1代表下标</span></span><br><span class="line">        <span class="keyword">var</span> stack = [(<span class="type">TreeNode</span>, <span class="type">Int</span>)]()</span><br><span class="line">        stack.append((root, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">var</span> maxWidth = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> !stack.isEmpty &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 层序遍历</span></span><br><span class="line">            <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;stack.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> (node, stackIndex) = stack.removeFirst()</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">left</span> = node.<span class="keyword">left</span> &#123;</span><br><span class="line">                    stack.append((<span class="keyword">left</span>, stackIndex &amp;* <span class="number">2</span>))</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="keyword">right</span> = node.<span class="keyword">right</span> &#123;</span><br><span class="line">                    stack.append((<span class="keyword">right</span>, stackIndex &amp;* <span class="number">2</span> &amp;+ <span class="number">1</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> stack.<span class="built_in">count</span> &gt; <span class="number">1</span> &#123;</span><br><span class="line">                <span class="comment">// 算出下一层的宽度和已遍历层的最大宽度</span></span><br><span class="line">                <span class="keyword">let</span> maxFloorWidth = stack.last!.<span class="number">1</span> &amp;- stack.first!.<span class="number">1</span> &amp;+ <span class="number">1</span>;</span><br><span class="line">                maxWidth = <span class="built_in">max</span>(maxWidth, maxFloorWidth)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxWidth</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跑一下力扣</p>
<p><img src="/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A62.png" alt="二叉树的最大宽度"></p>
<p>速度和性能都不错在swift横向对比中，代表也表简介</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>其实本质就是借用满二叉树的思路配合层序遍历，找出最值</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>不同类型的block</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在之前，打印过block的类型，显示是<strong>NSGlobalBlock</strong>，那么有没有其他类型的block呢，都是些什么类型呢。</p>
<h4 id="block类型的区分"><a href="#block类型的区分" class="headerlink" title="block类型的区分"></a>block类型的区分</h4><p>我们可以按照自己的类型，然后来打印对应的class，但是在做这些之前，我们先把环境切换到MRC。然后写下demo里的代码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span>(^block1)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"不访问任何东西"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        auto <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">void</span>(^block2)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"访问了个auto变量=%d"</span>,a);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">void</span>(^block3)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"访问了个static变量=%d"</span>,b);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *class1 = <span class="built_in">NSStringFromClass</span>([block1 <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSString</span> *class2 = <span class="built_in">NSStringFromClass</span>([block2 <span class="keyword">class</span>]);</span><br><span class="line">        <span class="built_in">NSString</span> *class3 = <span class="built_in">NSStringFromClass</span>([block3 <span class="keyword">class</span>]);</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"block1=%@,block2=%@,block3=%@"</span>,class1,class2,class3);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果如下</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block1.png" alt="不同类型的block1"></p>
<p>发现除了访问了auto局部变量的是栈block，其他的都是全局block。但是先别急，我们对栈block处理一下。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">auto <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">void</span>(^block2)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"访问了个auto变量=%d"</span>,a);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span>(^block4)(<span class="keyword">void</span>) = [block2 <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *class4 = <span class="built_in">NSStringFromClass</span>([block4 <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"对栈blockcopy之后为%@"</span>,class4);</span><br></pre></td></tr></table></figure>

<p>打印结果如下</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block2.png" alt="不同类型的block1"></p>
<p>到目前，我们就知道了block原来区分为了3种,总结一下如下图</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block3.png" alt="不同类型的block1"></p>
<h4 id="block的copy"><a href="#block的copy" class="headerlink" title="block的copy"></a>block的copy</h4><p>在上一节中，我们发现不访问任何局部auto变量的就是全局block，关于这个不去再做研究，因为实际应用中这种block很少，而且也不会有什么内存歧义，不涉及到任何捕获变量的问题</p>
<p>然后我们还发现对stackblock进行copy之后变成了mallocblock,那么对其他类型的block进行copy会有什么样的结果呢</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>(^block1)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"不访问任何东西"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^block4)(<span class="keyword">void</span>) = [block2 <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^globalBlockCopy)(<span class="keyword">void</span>) = [block1 <span class="keyword">copy</span>];</span><br><span class="line"><span class="keyword">void</span>(^mallocBlockCopyAgain)(<span class="keyword">void</span>) = [block4 <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"对全局blockcopy之后为%@,对堆block再次copy结果为%@"</span>,globalBlockCopy,mallocBlockCopyAgain);</span><br></pre></td></tr></table></figure>

<p>打印结果如下</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block4.png" alt="不同类型的block1"></p>
<p>所以对于类型来说没有影响，但是其实引用计数是有影响的，因为这是mrc。总结如图</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block5.png" alt="不同类型的block1"></p>
<h4 id="NSMallocBlock"><a href="#NSMallocBlock" class="headerlink" title="NSMallocBlock"></a><strong>NSMallocBlock</strong></h4><p>首先让我们回到ARC,毕竟我们的实际开发还是是在ARC的环境下的，只是暂时借助MRC让我们聚焦于本质。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">auto <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">void</span>(^block2)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"访问了个auto变量=%d"</span>,a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,block2);</span><br></pre></td></tr></table></figure>

<p>还是这段代码，在mrc下打印为stackblock,copy之后就变成mallocblock了。那么在ARC下是什么结果呢</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block6.png" alt="不同类型的block1"></p>
<p>会发现就直接是一个堆block了。为什么会这样呢，是因为在ARC情况下，block被强引用的时候会被copy，所以变成了堆block。我们可以这样处理一下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    auto <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">void</span>(^block2)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"访问了个auto变量=%d"</span>,a);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,block2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候结果就会变成</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84block7.png" alt="不同类型的block1"></p>
<p>所以我们日常接触中，基本上接触的都是堆block。那么为什么我们定义block成员变量要用copy或者strong来修饰呢，其实也是这个原理。还有日常接触的gcd是什么block呢，其实也是堆block</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>让我们聚焦堆block，可以总结一下几点</p>
<ul>
<li><p>在ARC环境下，编译器会根据情况自动将栈上的block复制到堆上，比如以下情况</p>
<ol>
<li>block作为函数返回值时</li>
<li>将block赋值给__strong指针时</li>
<li>block作为Cocoa API中方法名含有usingBlock的方法参数时</li>
<li>block作为GCD API的方法参数时</li>
</ol>
</li>
<li><p>ARC下block属性的建议写法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="keyword">void</span> (^block)(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>摄影入门</title>
    <url>/%E6%91%84%E5%BD%B1/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>因为最近生活中有一些拍照需求，又觉得手机拍的不是那么好。所以一冲动入了相机的坑，在看了一大堆测评之后先买了个xs10 1680套机玩了玩，后面又由于需要拍人像(女朋友)，需要定焦大光圈，又入了个35 1.4。出去旅游的时候拍了不少，确实也出了一些不错的照片。但是都是靠量取胜，完全没有构图、色彩、以及一些其他参数的概念，而是靠着模特底子好以及数量还有大光圈取胜。总觉得这件事就和写代码一样，每次按快门之前应该会有一些自己的思考，于是决定从头系统的学一学摄影这件事</p>
<h4 id="成像原理"><a href="#成像原理" class="headerlink" title="成像原理"></a>成像原理</h4><p>虽然我买的是微单(听说这是后来的趋势)，但是也可以从<strong><em>单反的成像原理</em></strong>来说</p>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A81.png" alt="摄影入门"></p>
<p>本质来说，摄影就是把光信号最终通过一些元件来转化成电子信号保存起来当图片的过程，最终呈现的结果其实就是感光器按下快门这一刻所进的光。例如上图，在光线进入，通过反光板折射的目镜时，我们就可以通过取景器看到我们想拍的东西。但是这并不是最终我们得到的图片，因为在我们按下快门的一瞬间，只会发反光板抬起来，让光线传递到感光器，从而形成我们拍摄的图片。</p>
<p><strong><em>微单（无反）的成像原理</em></strong></p>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A82.png" alt="摄影入门"></p>
<p>相对于来说单反来说，无反并没有反光板这个部件，取代的是ccd电子元件。没有反光板，所以叫无反相机。ccd相当于反光板来说，更加可靠和快速，并且这是机械部件到电子部件的跨越。从而因为有了ccd，也可以直接通过信号处理转化到显示屏上(屏幕取景器)上。</p>
<h4 id="曝光的三要素"><a href="#曝光的三要素" class="headerlink" title="曝光的三要素"></a>曝光的三要素</h4><p>在之前我们说了，摄影的本质其实就是把这一刻进的光转化成图片的过程，所以这一刻的进光量就很关键，我们有个专业名词，叫做<strong><u>曝光</u></strong>，然后曝光又由3个很关键的三要素组成</p>
<ul>
<li><p><em>光圈</em>  : <a href="https://baike.baidu.com/item/光圈/94964?fr=aladdin" target="_blank" rel="noopener">光圈</a>是一个用来控制光线透过镜头，进入机身内感光面光量的装置,就可以理解为他管理着进光口的大小，越大，单位时间内获得的光就越多。 表示光圈大小用F数表示,例如我的1680的套头的光圈就是F4，而35 1.4镜头的光圈是F1.4,要注意的是F后面数字越大，进光量越小，是一个反比关系。</p>
<blockquote>
<p>光圈的作用在于决定镜头的进光量。在快门不变的情况下：</p>
<p>F后面的数值越小，光圈越大，进光量越多，画面比较亮，焦平面越窄，主体背景虚化越大；</p>
<p>F后面的数值越大，光圈越小，进光量越少，画面比较暗，焦平面越宽，主体前后越清晰。</p>
</blockquote>
<p>所以我们拍人文一般都是大光圈，虚化背景，突出人物</p>
</li>
<li><p><em>快门</em> : <a href="https://baike.baidu.com/item/快门/82245?fr=aladdin" target="_blank" rel="noopener">快门</a>（shutter）是摄像器材中用来控制光线照射感光元件时间的装置。他控制着单次快门下进光的时间，快门速度越快，越可以抓住极速的物体。反之越慢就会有一些光的残影和运动轨迹。这并不代表快门越快越好，快门的快慢都有不同的利用场景，例如慢快门就可以拿来记录晚上城市道路上的车水马龙，假设我们拍一辆车子，定了快门时间2s。我们就可以拍出这辆车2s内的灯光的运动轨迹</p>
</li>
<li><p><em>感光度</em> : <a href="https://baike.baidu.com/item/感光度/2577807?fr=aladdin" target="_blank" rel="noopener">感光度</a>，又称为ISO值，是衡量底片对于光的灵敏程度。光在经过光圈和快门控制后，最终要通过感光元件。这个程度也会影响着最终成像的结果,感光度越小，最终成像越细腻。反之噪点越大</p>
</li>
</ul>
<p>我们可以用一个简单的图来更加通俗的说明这件事</p>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A8/%E6%91%84%E5%BD%B1%E5%85%A5%E9%97%A83.png" alt="摄影入门"></p>
<p>我们把单次打开水龙头和关闭水龙头这一组动作理解成按一次快门</p>
<p>水管宽度理解成光圈，越宽，进水(光)量越多</p>
<p>最终经过滤网(感光度)，拿到这次接到所有的水(光)。滤网越小(指的是孔)，水越细腻，越大杂质越多(燥点)</p>
<h4 id="曝光补偿"><a href="#曝光补偿" class="headerlink" title="曝光补偿"></a>曝光补偿</h4><p>曝光补偿指的是一种描述，当我们在取景器看到图片亮度不够的时候，我们可以告诉相机当前曝光有所欠缺。</p>
<p>当曝光补偿=0时，相机认为这样的曝光刚刚好，曝光补偿=-3时，相机认为这样的曝光欠曝三个单位。就会在最终成像上修正光的亮度</p>
<h4 id="常用的三个档位"><a href="#常用的三个档位" class="headerlink" title="常用的三个档位"></a>常用的三个档位</h4><p>在相机上，有一个专门的拨盘来控制着拍摄的模式(档位)</p>
<ul>
<li><strong><em>手动</em></strong>  光圈快门感光度全部自己设定，适合非常老手的玩家，因为最终的进光量的3个参数都由自己控制，很容易过爆或者曝光不足</li>
<li><strong><em>光圈优先（自动档）</em></strong> 通过曝光补偿来修正最终进了多少光，只控制光圈，剩下让相机自己对应修正，例如光线不好，相机就会降低快门速度和提高iso。控制光圈就影响着最终的景深</li>
<li><strong><em>快门优先（自动档）</em></strong> 通过曝光补偿来修正最终进了多少光，只控制快门速度，剩下的让相机自己对应修正。控制快门速度影响着拍摄的时间，和成像的质量(是否有光的轨迹)</li>
</ul>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>其实这些是一些非常理论的知识，通过学了这些之后之前拍摄遇到的一些问题可算豁然开朗。然后最终成像的三要素曝光只是其中之一,还有<strong>对焦</strong>和<strong>构图</strong>。对焦打算先放一放，因为现在的相机的对焦都非常智能了，可能下一步需要学习的就是构图。</p>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
  </entry>
  <entry>
    <title>基本安全防护记录</title>
    <url>/%E9%80%86%E5%90%91/%E5%9F%BA%E6%9C%AC%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>​    最近准备做一些基础的安全防护的功能，从最基础的反调试、反动态库注入，到反防护代码之间的博弈。发现了解越深懂的越不足。但是还是对这些基本的工作做一个简单的记录</p>
<h4 id="基础的防护"><a href="#基础的防护" class="headerlink" title="基础的防护"></a>基础的防护</h4><ul>
<li><p>反调试</p>
<ul>
<li><p>Ptrace</p>
<blockquote>
<ol>
<li><p>程序被Xcode安装直接闪退</p>
</li>
<li><p>通过终端lldb附加失败</p>
</li>
<li><p>用户可以正常启动</p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptrace (PT_DENY_ATTCH,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>sysctl</p>
<blockquote>
<ol>
<li><p>这个函数的作用去检测进程的一些状态，其中可选之一的参数就是进程的被附加状态</p>
</li>
<li><p>sysctl（查询信息的数组（放字节码），数组的大小，结构信息的结构体指针，结构体大小，和2一样，和3一样）</p>
</li>
<li><p>在接受信息的结构体中，kp_proc属性 有一个标记 p_flag</p>
</li>
<li><p>查看第12位 是否为 1（1代表着有调试器附加）可通过P_TRACED查询</p>
</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> name[<span class="number">4</span>];<span class="comment">//里面放字节码。查询的信息</span></span><br><span class="line">name[<span class="number">0</span>] = CTL_KERN;<span class="comment">//内核查询</span></span><br><span class="line">name[<span class="number">1</span>] = KERN_PROC;<span class="comment">//查询进程</span></span><br><span class="line">name[<span class="number">2</span>] = KERN_PROC_PID;<span class="comment">//传递的参数是进程的ID</span></span><br><span class="line">name[<span class="number">3</span>] = getpid();<span class="comment">//PID的值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kinfo_proc</span> <span class="title">info</span>;</span><span class="comment">//接受查询结果的结构体</span></span><br><span class="line"><span class="keyword">size_t</span> info_size = <span class="keyword">sizeof</span>(info);</span><br><span class="line"><span class="keyword">if</span>(sysctl(name, <span class="number">4</span>, &amp;info, &amp;info_size, <span class="number">0</span>, <span class="number">0</span>))&#123;</span><br><span class="line">    NSLog(@<span class="string">"查询失败"</span>);</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看info.kp_proc.p_flag 的第12位。如果为1，表示调试状态。</span></span><br><span class="line"><span class="comment">//(info.kp_proc.p_flag &amp; P_TRACED)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((info.kp_proc.p_flag &amp; P_TRACED) != <span class="number">0</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>反动态库注入</p>
<p>其实就是在上线前记录所有的动态库的名字，拼接成字符串。上线后通过dyld来循环获取每一个动态库是否是在字符串中有记录，如果没有说明是被注入的，可以做异常上报</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = _dyld_image_count();<span class="comment">//加载了多少数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">//遍历拿到库名称！</span></span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">char</span> * imageName = _dyld_get_image_name(i);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strstr</span>(libraries, imageName)&amp;&amp;!<span class="built_in">strstr</span>(imageName, <span class="string">"/var/mobile/Containers/Bundle/Application"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// report libary &amp;&amp; user info</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>获取是否是越狱状态</p>
<p>​      直接通过获取进程的dyld是否有动态库插入来判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> * dlname = getenv(<span class="string">"DYLD_INSERT_LIBRARIES"</span>);</span><br><span class="line">  <span class="keyword">if</span> (dlname) &#123;</span><br><span class="line">      <span class="keyword">return</span> YES;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> NO;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="对防护的简单攻击"><a href="#对防护的简单攻击" class="headerlink" title="对防护的简单攻击"></a>对防护的简单攻击</h4><p>   对于有经验的工程师，肯定会第一时间去把ptrace和sysctl直接干掉，这点很简单，通过fishhook就可以做到</p>
<ul>
<li>破解ptrace<ul>
<li>通过fishhook函数勾住ptrace</li>
<li>判断参数1，是否拒绝附加，如果是，就直接返回</li>
</ul>
</li>
<li>破解sysctl<ul>
<li>通过fishhook函数勾住sysctl</li>
<li>调用原始的函数</li>
<li>取出结构一的标记判断</li>
<li>通过异或 P_TRACED 取反。修改标记，达到破解的效果</li>
</ul>
</li>
</ul>
<h4 id="进一层的防护"><a href="#进一层的防护" class="headerlink" title="进一层的防护"></a>进一层的防护</h4><p>  为了避免被简单攻击给攻击到，所以一般会做进一层的防护，基本原理还是围绕着上面的那些，但是只是做得更隐秘，不会被简单的干掉</p>
<ul>
<li><p>提前执行 将检测函数放入Framwork中</p>
</li>
<li><p>混淆类名、方法名：通过宏定义，写入PCH文件进行类名、方法名混淆。</p>
</li>
<li><p>字符串加密：所有的字符串常量拆分成字符，然后通过异或运算隐藏字符串常量</p>
</li>
<li><p>syscall：通过syscall 调用系统函数，使用fishhook和lldb 符号断点都拿不到。例如调用ptrace我们可以这样做,其中的对应的数字编号都在对应的头文件记载</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">syscall(<span class="number">26</span>,<span class="number">31</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>防护fishhook：通过 dlopen（）拿到模块句柄 、 通过 dlsym（）获得函数地址，例如直接ptrace我们可以换一种方式做，其中也用到了上面所说的字符串变相加密，避免直接去常量区找到了“ptrace”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拼接一个 ptrace</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> funcStr[] = &#123;</span><br><span class="line">      (<span class="string">'a'</span> ^ <span class="string">'p'</span>),</span><br><span class="line">      (<span class="string">'a'</span> ^ <span class="string">'t'</span>),</span><br><span class="line">      (<span class="string">'a'</span> ^ <span class="string">'r'</span>),</span><br><span class="line">      (<span class="string">'a'</span> ^ <span class="string">'a'</span>),</span><br><span class="line">      (<span class="string">'a'</span> ^ <span class="string">'c'</span>),</span><br><span class="line">      (<span class="string">'a'</span> ^ <span class="string">'e'</span>),</span><br><span class="line">      (<span class="string">'a'</span> ^ <span class="string">'\0'</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> * p = funcStr;</span><br><span class="line">  <span class="keyword">while</span> (((*p) ^= <span class="string">'a'</span>) != <span class="string">'\0'</span>) p++;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//通过dlopen拿到句柄</span></span><br><span class="line">  <span class="keyword">void</span> * handle = dlopen(<span class="string">"/usr/lib/system/libsystem_kernel.dylib"</span>, RTLD_LAZY);</span><br><span class="line">  <span class="comment">//定义函数指针</span></span><br><span class="line">  <span class="keyword">int</span> (*ptrace_p)(<span class="keyword">int</span> _request, <span class="keyword">pid_t</span> _pid, <span class="keyword">caddr_t</span> _addr, <span class="keyword">int</span> _data);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">      ptrace_p = dlsym(handle, (<span class="keyword">const</span> <span class="keyword">char</span> *)funcStr);</span><br><span class="line">      <span class="keyword">if</span> (ptrace_p) &#123;</span><br><span class="line">          ptrace_p(PT_DENY_ATTACH, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>汇编软中断的方式触发系统函数，在代码中，我们可以直接写内联汇编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __arm64__</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="string">"mov x0,#26\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="string">"mov x1,#31\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="string">"mov x2,#0\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="string">"mov x3,#0\n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="string">"mov x16,#0\n"</span><span class="comment">//中断根据x16 里面的值，跳转syscall</span></span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="string">"svc #0x80\n"</span><span class="comment">//这条指令就是触发中断（系统级别的跳转！）</span></span></span></span><br><span class="line"><span class="function"><span class="params">     )</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>其实攻防就是有攻就有防，本来就是双方的博弈，基于上面的加密也可以再做防护。作为防护方要做的就是避免被找到防护代码，攻击方就是找到防护代码然后干掉它。做到后面就是反调试、反反调试、反反反调试。听起来像套娃，具体能做到第几层也是根据经验来做进一步取舍</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>向super发消息</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E5%90%91super%E5%8F%91%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>关于一道面试题，定义一个父类，实现一个函数，函数里打印self。然后再定义一个继承于这个类的子类。然后重写这个函数，在函数里调用super xxx，请问打印结果。其实这个结果我很早之前就知道，是打印的子类。但是还是想探究一下为什么，所以有了这篇博客</p>
<h4 id="objc-msgSendSuper"><a href="#objc-msgSendSuper" class="headerlink" title="objc_msgSendSuper"></a>objc_msgSendSuper</h4><p>首先验证下自己的猜想，建2个类，写出需要的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        Girl *g &#x3D; [[Girl alloc] init];</span><br><span class="line">        [g test];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation Girl</span><br><span class="line">- (void)test &#123;</span><br><span class="line">    [super test];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E5%90%91super%E5%8F%91%E6%B6%88%E6%81%AF/%E5%90%91super%E5%8F%91%E6%B6%88%E6%81%AF1.png" alt="向super发消息"></p>
<p>果然不出所料，打印结果如下。为了弄清楚为什么，还是老办法，编译成c++。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Girl_test(Girl * self, SEL _cmd) &#123;</span><br><span class="line">    ((<span class="keyword">void</span> (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123;(id)self, (id)class_getSuperclass(objc_getClass(<span class="string">"Girl"</span>))&#125;, sel_registerName(<span class="string">"test"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rw_objc_super</span> &#123;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">object</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">superClass</span>;</span> </span><br><span class="line">    __rw_objc_super(struct objc_object *o, struct objc_object *s) : object(o), superClass(s) &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实弄清楚了就是调用了objc_msgSendSuper函数，然后2个参数，第一个参数是一个__rw_objc_super的结构体，还有一个就是方法的sel。</p>
<p>然后__rw_objc_super2个成员一个是自己当前的对象，另外一个是自己的父类对象。</p>
<p>但是觉得还是不够清晰，所以还是去看下objc_msgSendSuper的源码，很不幸，汇编实现的。而且描述得也不是很清楚</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">ENTRY _objc_msgSendSuper</span><br><span class="line">UNWIND _objc_msgSendSuper, NoFrame</span><br><span class="line">MESSENGER_START</span><br><span class="line"></span><br><span class="line">ldp    <span class="keyword">x</span><span class="number">0</span>, <span class="keyword">x</span><span class="number">16</span>, [<span class="keyword">x</span><span class="number">0</span>]        // <span class="keyword">x</span><span class="number">0</span> = real receiver, <span class="keyword">x</span><span class="number">16</span> = class</span><br><span class="line">CacheLookup NORMAL        // calls imp <span class="keyword">or</span> objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSendSuper</span><br></pre></td></tr></table></figure>

<p>就看到取了16个字节放到x0和x16，注释说x0是真正的消息接收者。x16是类，其实这个x0就是上面的objcet也就是girl对象。然后x16类就是父类。然后去执行函数去了。另外可以在苹果的注释也可以看到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Sends a message with a simple return value to the superclass of an instance of a class.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param super A pointer to an \c objc_super data structure. Pass values identifying the</span></span><br><span class="line"><span class="comment"> *  context the message was sent to, including the instance of the class that is to receive the</span></span><br><span class="line"><span class="comment"> *  message and the superclass at which to start searching for the method implementation.</span></span><br><span class="line"><span class="comment"> * @param op A pointer of type SEL. Pass the selector of the method that will handle the message.</span></span><br><span class="line"><span class="comment"> * @param ...</span></span><br><span class="line"><span class="comment"> *   A variable argument list containing the arguments to the method.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return The return value of the method identified by \e op.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @see objc_msgSend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT id _Nullable</span><br><span class="line">objc_msgSendSuper(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Specifies the superclass of an instance. </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span><br><span class="line">    <span class="comment">/// Specifies an instance of a class.</span></span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Specifies the particular superclass of the instance to message. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(__cplusplus)  &amp;&amp;  !__OBJC2__</span></span><br><span class="line">    <span class="comment">/* For compatibility with old objc-runtime.h header */</span></span><br><span class="line">    __unsafe_unretained _Nonnull Class <span class="class"><span class="keyword">class</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* super_class is the first class to search */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>其实这个结构体的对象的第一个变量是消息接受者。然后第二个类只是说明到时候找imp的时候是从哪个类的实现开始找。</p>
<p>另外要说一点的是oc所有的方法的本质都是转换成objc_msgSend来做的调用，然后固定有2个参数，第1个是消息接受者。也就是我们函数里敲出来的self。所以在刚入门iOS的时候理解成函数当前的对象和类是没问题的，但是本质这个self其实是默认参数消息接受者。第二个参数是_cmd，类型就是SEL类型。如果需要其他参数则是放到后续的寄存器存放的。</p>
<p>所以我们也理解到了，调用super只不过是从父类去查找方法而已，然后消息接受者还是自己。</p>
<h4 id="objc-msgSendSuper2"><a href="#objc-msgSendSuper2" class="headerlink" title="objc_msgSendSuper2"></a>objc_msgSendSuper2</h4><p>有一点要说明，用clang转换成c++并不是百分之百的准确，但是也足够帮我们了解底层了。例如上面调用super我们编译出来显示执行的是objc_msgSendSuper,但是事实其实有出入。我们直接打断点查看</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E5%90%91super%E5%8F%91%E6%B6%88%E6%81%AF/%E5%90%91super%E5%8F%91%E6%B6%88%E6%81%AF2.png" alt="向super发消息"></p>
<p>尽管是x86的汇编，我们依然也可看到，最后调用的是objc_msgSendSuper2。查看源码，还是汇编。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ENTRY _objc_msgSendSuper<span class="number">2</span></span><br><span class="line">UNWIND _objc_msgSendSuper<span class="number">2</span>, NoFrame</span><br><span class="line">MESSENGER_START</span><br><span class="line"></span><br><span class="line">ldp    <span class="keyword">x</span><span class="number">0</span>, <span class="keyword">x</span><span class="number">16</span>, [<span class="keyword">x</span><span class="number">0</span>]        // <span class="keyword">x</span><span class="number">0</span> = real receiver, <span class="keyword">x</span><span class="number">16</span> = class</span><br><span class="line">ldr    <span class="keyword">x</span><span class="number">16</span>, [<span class="keyword">x</span><span class="number">16</span>, #SUPERCLASS]    // <span class="keyword">x</span><span class="number">16</span> = class-&gt;superclass</span><br><span class="line">CacheLookup NORMAL</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSendSuper<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可以看到只不过自己手动执行了一个superclass，然后赋值然后进行执行。可以借用非arm64的汇编看得更清楚</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment"> * id objc_msgSendSuper2(struct objc_super *super, SEL op, ...)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * struct objc_super &#123;</span></span><br><span class="line"><span class="comment"> *     id receiver;</span></span><br><span class="line"><span class="comment"> *     Class cls;    // SUBCLASS of the class to search</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> ********************************************************************/</span></span><br><span class="line">    </span><br><span class="line">    ENTRY _objc_msgSendSuper2</span><br><span class="line">    MESSENGER_START</span><br><span class="line">    </span><br><span class="line">    ldr    r9, [r0, #CLASS]    <span class="comment">// class = struct super-&gt;class</span></span><br><span class="line">    ldr    r9, [r9, #SUPERCLASS]   <span class="comment">// class = class-&gt;superclass</span></span><br><span class="line">    CacheLookup NORMAL</span><br><span class="line">    <span class="comment">// cache hit, IMP in r12, eq already set for nonstret forwarding</span></span><br><span class="line">    ldr    r0, [r0, #RECEIVER]    <span class="comment">// load real receiver</span></span><br><span class="line">    MESSENGER_END_FAST</span><br><span class="line">    bx    r12            <span class="comment">// call imp</span></span><br><span class="line"></span><br><span class="line">    CacheLookup2 NORMAL</span><br><span class="line">    <span class="comment">// cache miss</span></span><br><span class="line">    ldr    r9, [r0, #CLASS]    <span class="comment">// class = struct super-&gt;class</span></span><br><span class="line">    ldr    r9, [r9, #SUPERCLASS]   <span class="comment">// class = class-&gt;superclass</span></span><br><span class="line">    ldr    r0, [r0, #RECEIVER]    <span class="comment">// load real receiver</span></span><br><span class="line">    MESSENGER_END_SLOW</span><br><span class="line">    b    __objc_msgSend_uncached</span><br><span class="line">    </span><br><span class="line">    END_ENTRY _objc_msgSendSuper2</span><br></pre></td></tr></table></figure>

<p>结构体的第二个参数就是自己的class了，不过内部执行会取出superclass作为方法的搜索起始值。其实就是包装了一层。和我们之前理解的原理其实没有太大出入</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>我们基本理清了super 发送消息到底做了什么事，其实只用搞清楚函数内部的self其实是消息接受者就可以了。剩下就是弄清函数接受者是谁就一切很清晰明了</p>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>构图初步学习</title>
    <url>/%E6%91%84%E5%BD%B1/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在掌握了基础的光线之后，构图作为拍摄三要素之一也很重要。构图简单来理解就是我们在相框里的要摆放什么，他们的相对位置是怎么样的，从什么角度去拍摄他们。所谓”横看成岭侧成峰”其实就可以理解我们构图的一部分，但是作为没有任何美术基础和审美基础的死宅男。学习这一部分真的很困难，只能死记硬背然后多看举一反三了。写这篇博客也只是为了做一个简单的笔记</p>
<h4 id="构图的本质"><a href="#构图的本质" class="headerlink" title="构图的本质"></a>构图的本质</h4><ul>
<li><strong>取舍</strong></li>
</ul>
<p>​       首先一张图是有边界的，所以这就涉及到了取舍。一张图中会有很多元素，我们可以选择保留哪些元素</p>
<ul>
<li><strong>位置</strong></li>
</ul>
<p>​       图中元素相对应的位置是可以调整的–模特是可以移动的(假设人文)</p>
<ul>
<li><p><strong>视角</strong></p>
<p>元素的相对应的位置(联系)也可以通过机位调整—横看成岭侧成峰。正对着拍会显得有仪式感。可以尝试不同的视角从上往下、从下往上、从上往上、从下往下。寻找对比留白，多尝试</p>
</li>
</ul>
<h4 id="一些基本的构图模式"><a href="#一些基本的构图模式" class="headerlink" title="一些基本的构图模式"></a>一些基本的构图模式</h4><ul>
<li><p>中心构图</p>
<p>中心构图法算是新手最常用的方法，简单来说就是把物体放在画面正中拍摄，优点就在于主体突出、明确，而且画面容易取得左右平衡的效果，主体要选择相对饱满的，所占的比例要稍微大一些。单独的条状体不适合使用中心构图，容易显得突兀。当然，主体也不是越大越好，要根据实际情况来定。</p>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A01.png" alt="构图初步学习1"></p>
</li>
<li><p>对称构图</p>
<p>对称式构图，是指在画面正中垂线两侧或正中水平线上下，对等或大致对等的构图模式。这种构图，布局均衡，结构规矩，给人平衡、平稳、庄重的感觉。对称式构图具有平衡、稳定、相呼应的特点。缺点：呆板、缺少变化。常用于表现对称的物体、建筑、特殊风格的物体。<strong>几何对称的场景都是恩赐</strong></p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A02.png" alt="构图初步学习1"></p>
<ul>
<li><p>三分法构图</p>
<p><strong>三分法、万能的构图法则</strong></p>
<p>三分法构图，又称九宫格法，指的是将单反相机取景器中所能看到的画面，横竖三等分的比例分割画面后，当被摄对象以线条的形式出现时，可将其置于画面的任意一条三分线位置。这种构图形式能够在视觉上带给人愉悦和生动地感受，避免主体居中而产生的呆板感。</p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A03.png" alt="构图初步学习1"></p>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A04.png" alt="构图初步学习1"></p>
<ul>
<li><p>对角线构图</p>
<p>物体在画幅中两对角的连线，近似于对角线，名由形状来定的。把主题安排在对角线上，有立体感、延伸感和运动感。</p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A05.png" alt="构图初步学习1"></p>
<ul>
<li><p>点缀法构图</p>
<p> 以下衬大，让主题更加突出并且不单调，有相应的对比</p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A06.png" alt="构图初步学习1"></p>
<ul>
<li><p>引导线法构图</p>
<p>引导线构图方法，就是利用画面中的线条去引导观者的目光，让他的目光最终可以汇聚到画面的焦点。当然引导线并不一定是具体的线，只要是有方向性的、连续的东西，我们都可以称之为引导线。</p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A07.png" alt="构图初步学习1"></p>
<ul>
<li><p>框景法构图</p>
<p>是指利用画面中景物的框架结构来包裹主体的构图方法。</p>
<p>框景构图具有很强的视觉引导效果，利用这一点可以将所要重点表现的景物突出呈现在画面之中。</p>
</li>
</ul>
<p><img src="/%E6%91%84%E5%BD%B1/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/%E6%9E%84%E5%9B%BE%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A08.png" alt="构图初步学习1"></p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>老师说其实构图<strong>把一些东西，遵照一定的目的性，有美感的摆放在一张有边界的图中</strong>，但是我还是做不好这件事。只能多尝试多学习，多看，多拍。</p>
<p>​           </p>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈函数调用栈</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E6%B5%85%E8%B0%88%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>目前项目需要做一个检测卡顿的工具，但是在检测卡顿完我们肯定是希望能找出具体的函数调用栈方便查找问题以及业务同学更改。所以我们需要提前准备一个能够实时查看函数调用栈的工具，其实这些已经有比较成熟的方案了，但是我们还是需要知道这些原理。</p>
<h3 id="系统方法"><a href="#系统方法" class="headerlink" title="系统方法"></a>系统方法</h3><p>我们知道 <code>NSThread</code> 有一个类方法 <code>callstackSymbols</code> 可以获取调用栈，但是它输出的是当前线程的调用栈。局限性很大，我们更多的时候是在一个子线程长期观测其他线程的状态</p>
<p>最简单、自然的想法就是利用 <code>dispatch_async</code> 或 <code>performSelectorOnMainThread</code> 等方法，回到主线程并获取调用栈。但是并不可行</p>
<p>我们以 <code>UIViewController</code> 的<code>viewDidLoad</code> 方法为例，推测它底层都发生了什么。</p>
<p>首先主线程也是线程，就得按照线程基本法来办事。线程基本法说的是首先要把线程运行起来，然后(如果有必要，比如主线程)启动 runloop 进行保活。我们知道 runloop 的本质就是一个死循环，在循环中调用多个函数，分别判断 source0、source1、timer、dispatch_queue 等事件源有没有要处理的内容。</p>
<p>和 UI 相关的事件都是 source0，因此会执行 <code>__CFRunLoopDoSources0</code>，最终一步步走到 <code>viewDidLoad</code>。当事件处理完后 runloop 进入休眠状态。</p>
<p>假设我们使用 <code>dispatch_async</code>，它会唤醒 runloop 并处理事件，但此时 <code>__CFRunLoopDoSources0</code> 已经执行完毕，不可能获取到 <code>viewDidLoad</code> 的调用栈。</p>
<p><code>performSelector</code> 系列方法的底层也依赖于 runloop，因此它只是像当前的 runloop 提交了一个任务，但是依然要等待现有任务完成以后才能执行，所以拿不到实时的调用栈。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><a href="[https://zh.wikipedia.org/zh/%E5%AF%84%E5%AD%98%E5%99%A8](https://zh.wikipedia.org/zh/寄存器)">寄存器</a></h3><p>寄存器是和CPU联系非常紧密的一小块内存，经常用于存储一些正在使用的数据。ARM64 有34个寄存器，包括31个通用寄存器、SP、PC、CPSR。调用约定指定他们其中的一些寄存器有特殊的用途，例如：</p>
<ul>
<li>x0-x28：通用寄存器，如果有需要可以当做32bit使用：WO-W30(兼容32位)</li>
<li>x29(FP)：通常用作桢指针fp（frame pointer寄存器），栈帧基址寄存器，指向当前函数栈帧的栈底</li>
<li>x30(LR)：是链接寄存器lr(link register)。它保存了当目前函数返回时下一个函数的地址；</li>
<li>SP：栈指针sp(stack pointer)。在计算机科学内栈是非常重要的术语。寄存器存放了一个指向栈顶的指针。使用 SP/WSP来进行对SP寄存器的访问。</li>
<li>PC：是程序计数器pc(program counter)。它存放了当前执行指令的地址。在每个指令执行完成后会自动增加；</li>
<li>CPSR: 状态寄存器</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_STRUCT_ARM_THREAD_STATE64</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">__uint64_t</span> __x[<span class="number">29</span>];     <span class="comment">/* General purpose registers x0-x28 */</span></span><br><span class="line">    <span class="keyword">void</span>*      __opaque_fp; <span class="comment">/* Frame pointer x29 */</span></span><br><span class="line">    <span class="keyword">void</span>*      __opaque_lr; <span class="comment">/* Link register x30 */</span></span><br><span class="line">    <span class="keyword">void</span>*      __opaque_sp; <span class="comment">/* Stack pointer x31 */</span></span><br><span class="line">    <span class="keyword">void</span>*      __opaque_pc; <span class="comment">/* Program counter */</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> __cpsr;      <span class="comment">/* Current program status register */</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> __opaque_flags; <span class="comment">/* Flags describing structure format */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不同指令集的寄存器数量可能会不同，pc、lr、sp、fp也可能使用其中不同的寄存器。后面我们先忽略X29等寄存器编号，直接用fp，sp，lr来讲述</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a><a href="[https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88](https://zh.wikipedia.org/wiki/堆栈)">栈</a></h3><p>栈：是一种具有特殊的访问方式的存储空间（后进先出， Last In Out Firt，LIFO）</p>
<blockquote>
<p>Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配。比如，内存区域的结束地址是0x8000，第一帧假定是16字节，那么下一次分配的地址就会从0x7FF0开始；第二帧假定需要64字节，那么地址就会移动到0x7FB0。</p>
</blockquote>
<p>“调用栈”（call stack）既可以指具体实现，也可以指一种抽象概念——由“栈帧￼”（stack frame）或者叫“活动记录”（activation record）构成的栈</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E6%B5%85%E8%B0%88%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/stack_frame.png" alt="stack_frame"></p>
<p>​                                                     (图片来源自wikipedia)</p>
<p>在上图中，是2个函数的调用,<code>DrawSquare</code>调用了<code>DrwaLine</code>,其中绿色和蓝色就分别代表了2个栈帧，多个栈帧就组合了我们的函数调用栈，上图中是一个递增栈，但是在ARM中一般都是递减栈，但是我们可以看到，一张栈帧结构中包含着Return Address，也就是当前活动记录执行结束后要返回的地址（展开）。</p>
<p>那么，在我们获取到栈帧后，就可以通过返回地址来进行回溯了。</p>
<p>如下图所示，不管是较早的帧，还是调用者的帧，还是当前帧，它们的结构是完全一样的，因为每个帧都是基于一个函数，帧伴随着函数的生命周期一起产生、发展和消亡。在这个过程中用到了上面说的寄存器，fp(ebp)帧指针，它总是指向当前帧的底部；sp(esp)栈顶指针，它总是指向当前帧的顶部。这两个寄存器用来定位当前帧中的所有空间。编译器需要根据指令集的规则小心翼翼地调整这两个寄存器的值，一旦出错，参数传递、函数返回都可能出现问题。</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E6%B5%85%E8%B0%88%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/stackframe_x86.jpg" alt="stackframe_x86"></p>
<p>其实这里这几个寄存器会满足一定规则，比如：</p>
<ul>
<li>fp(ebp)指向的是当面栈帧的底部，该地址存的值是调用当前栈帧的上一个栈帧的fp(esp)的地址。</li>
<li>lr(eip)总是在上一个栈帧（也就是调用当前栈帧的栈帧）的顶部，而栈帧之间是连续存储的，所以lr也就是当前栈帧底部的上一个地址，以此类推就可以推出所有函数的调用顺序。这里注意，栈底在高地址，栈向下增长</li>
</ul>
<p><strong>Pseudocode</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(fp) &#123;</span><br><span class="line">  lr = *(fp + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// store lr</span></span><br><span class="line">  fp = *fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数的地址"><a href="#函数的地址" class="headerlink" title="函数的地址"></a>函数的地址</h3><p>在上面的过程中，我们可以拿到所有的LR的值，但是LR里保存的其实是一个cpu在执行完当前函数要返回的指令地址。我们怎么通过他拿到真正的函数入口地址呢。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcFirstStep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    funcSecondStep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">funcSecondStep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    funcFirstStep();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HookTest`funcFirstStep:</span><br><span class="line">-&gt;  <span class="number">0x1049e1600</span> &lt;+<span class="number">0</span>&gt;:  stp    x29, x30, [sp, #<span class="number">-0x10</span>]!</span><br><span class="line">    <span class="number">0x1049e1604</span> &lt;+<span class="number">4</span>&gt;:  mov    x29, sp</span><br><span class="line">    <span class="number">0x1049e1608</span> &lt;+<span class="number">8</span>&gt;:  bl     <span class="number">0x1049e1614</span>               ; funcSecondStep at main.m:<span class="number">20</span>:<span class="number">1</span></span><br><span class="line">    <span class="number">0x1049e160c</span> &lt;+<span class="number">12</span>&gt;: ldp    x29, x30, [sp], #<span class="number">0x10</span></span><br><span class="line">    <span class="number">0x1049e1610</span> &lt;+<span class="number">16</span>&gt;: ret</span><br></pre></td></tr></table></figure>

<p>这是<code>funcFirstStep</code>的汇编代码，<code>0x1049e1600</code>其实就是函数地址，但是我们只能拿到LR的地址,在执行完<code>0x1049e1608</code>这条跳转指令时，转到<code>funcSecondStep</code>的栈帧中，然后需要保存<code>0x1049e160c</code>这条地址(LR),用来保证cpu在执行完<code>funcSecondStep</code>知道继续在哪里执行。所以每个LR都有一个特点，他是距离他函数入口地址最近的一个LR,并且他的地址比函数入口地址大，大多少暂时未知，取决于当前函数要执行多少条pc寄存器的指令(也就是函数复杂度)，暂且让我们先记住这个特点。</p>
<h3 id="获取当前线程的寄存器状态"><a href="#获取当前线程的寄存器状态" class="headerlink" title="获取当前线程的寄存器状态"></a>获取当前线程的寄存器状态</h3><p>当检测到需要获取函数调用栈时，我们需要拿到当前的寄存器信息，正好mach有提供这样的一组API</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mach_msg_type_number_t</span> count = x86_THREAD_STATE64_COUNT;</span><br><span class="line">thread_get_state(thread, x86_THREAD_STATE64, (<span class="keyword">thread_state_t</span>)&amp;ctx.__ss, &amp;count);</span><br></pre></td></tr></table></figure>

<p>会根据传入的线程以及架构，返回对应的架构状态的结构体，其中就包括了线程寄存器状态，例如ARM64来说</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_STRUCT_MCONTEXT64</span><br><span class="line">&#123;</span><br><span class="line">    _STRUCT_ARM_EXCEPTION_STATE64   es;</span><br><span class="line">    _STRUCT_ARM_THREAD_STATE64      ss;</span><br><span class="line">    _STRUCT_ARM_NEON_STATE64        ns;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中ss就是就是我们在寄存器章节中提到的结构体。在源码中，还有这么一段代码,是为了适配cpu的架构类型适配，所以在传入cpu架构类型参数以及后续返回值的时候，我们也可以写对应的宏来做处理，方便代码的健壮性，这里就不展开了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _MCONTEXT_T</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _MCONTEXT_T</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__arm64__)</span></span><br><span class="line"><span class="keyword">typedef</span> _STRUCT_MCONTEXT64      *<span class="keyword">mcontext_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STRUCT_MCONTEXT _STRUCT_MCONTEXT64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> _STRUCT_MCONTEXT32      *<span class="keyword">mcontext_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STRUCT_MCONTEXT        _STRUCT_MCONTEXT32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _MCONTEXT_T */</span></span></span><br></pre></td></tr></table></figure>

<p>但是其中有一个关键参数是要传入线程<code>thread</code>,这是一个<code>thread_state_t</code>类型，即kernel线程，并不是NSThread，系统并没有提供直接转换的方法，所以我们需要先做线程转换。</p>
<h3 id="NSThread-转内核-thread"><a href="#NSThread-转内核-thread" class="headerlink" title="NSThread 转内核 thread"></a>NSThread 转内核 thread</h3><p>这一块也是比较大的知识，本质是一个映射的过程，具体可以参见上一篇博客<br><a href="/原理分析/NSThead和内核线程的转换">NSThead和内核线程的转换</a></p>
<h3 id="获取所有LR寄存器的实现"><a href="#获取所有LR寄存器的实现" class="headerlink" title="获取所有LR寄存器的实现"></a>获取所有LR寄存器的实现</h3><p>首先定义了一个数组，用来存放所有需要获取寄存器的值，自定义最大数量为50个，避免更深的栈的深度的性能问题，这个可以自己取舍。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getThreadAllLRandFirstPc</span><span class="params">(<span class="keyword">thread_t</span> thread, <span class="keyword">uintptr_t</span>* backtraceBuffer, <span class="keyword">int</span> * bufferLengh)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// get context</span></span><br><span class="line">    _STRUCT_MCONTEXT machineContext;</span><br><span class="line">    <span class="keyword">if</span>(!bs_fillThreadStateIntoMachineContext(thread, &amp;machineContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// pc</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uintptr_t</span> instructionAddress = bs_mach_instructionAddress(&amp;machineContext);</span><br><span class="line">    <span class="comment">// machineContext-&gt;__ss.pc;</span></span><br><span class="line">    backtraceBuffer[i] = instructionAddress;</span><br><span class="line">    ++i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// first lr</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> linkRegister = bs_mach_linkRegister(&amp;machineContext);</span><br><span class="line">    <span class="keyword">if</span> (linkRegister) &#123;</span><br><span class="line">        backtraceBuffer[i] = linkRegister;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(instructionAddress == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    BSStackFrameEntry frame = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// get fp</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uintptr_t</span> framePtr = bs_mach_framePointer(&amp;machineContext);</span><br><span class="line">    <span class="keyword">if</span>(framePtr == <span class="number">0</span> ||</span><br><span class="line">       <span class="comment">// read  16 byte start with fp, 8byte -&gt;lr ,8byte -&gt; last fp</span></span><br><span class="line">       bs_mach_copyMem((<span class="keyword">void</span> *)framePtr, &amp;frame, <span class="keyword">sizeof</span>(frame)) != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// recursion</span></span><br><span class="line">    <span class="keyword">for</span>(; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        backtraceBuffer[i] = frame.return_address;</span><br><span class="line">        <span class="keyword">if</span>(backtraceBuffer[i] == <span class="number">0</span> ||</span><br><span class="line">           frame.previous == <span class="number">0</span> ||</span><br><span class="line">           bs_mach_copyMem(frame.previous, &amp;frame, <span class="keyword">sizeof</span>(frame)) != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *bufferLengh = i;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h3><p>就像 “把大象关进冰箱需要几步” 一样，获取 函数 对应的符号名也可以分为以下几步:</p>
<ol>
<li>根据 LR或者PC 找到函数属于哪个镜像文件(也就是上面取出的那些地址)</li>
<li>找到镜像的符号表和字符串表</li>
<li>找到LR或者PC最接近符号表的哪个地址</li>
<li>在字符串表中找到接近的地址的函数名</li>
</ol>
<p>不过在这里需要注意一个内存对齐的问题，不同的操作系统对齐方式不一样，arm64指针是4字节对齐</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> -mark Symbolicate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bs_symbolicate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uintptr_t</span>* <span class="keyword">const</span> backtraceBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                    Dl_info* <span class="keyword">const</span> symbolsBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">int</span> numEntries,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">int</span> skippedEntries)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!skippedEntries &amp;&amp; i &lt; numEntries) &#123;</span><br><span class="line">        <span class="comment">// 第一次是pc寄存器，不需要考虑内存对齐</span></span><br><span class="line">        bs_dladdr(backtraceBuffer[i], &amp;symbolsBuffer[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(; i &lt; numEntries; i++) &#123;</span><br><span class="line">        <span class="comment">// 后续需要考虑到不同操作系统内存对齐的问题</span></span><br><span class="line">        bs_dladdr(CALL_INSTRUCTION_FROM_RETURN_ADDRESS(backtraceBuffer[i]), &amp;symbolsBuffer[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bs_dladdr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uintptr_t</span> address, Dl_info* <span class="keyword">const</span> info)</span> </span>&#123;</span><br><span class="line">    info-&gt;dli_fname = <span class="literal">NULL</span>;</span><br><span class="line">    info-&gt;dli_fbase = <span class="literal">NULL</span>;</span><br><span class="line">    info-&gt;dli_sname = <span class="literal">NULL</span>;</span><br><span class="line">    info-&gt;dli_saddr = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 寻找函数所在的镜像文件</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> idx = bs_imageIndexContainingAddress(address);</span><br><span class="line">    <span class="keyword">if</span>(idx == UINT_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拿到模块偏移值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span>* <span class="title">header</span> = _<span class="title">dyld_get_image_header</span>(<span class="title">idx</span>);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uintptr_t</span> imageVMAddrSlide = (<span class="keyword">uintptr_t</span>)_dyld_get_image_vmaddr_slide(idx);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uintptr_t</span> addressWithSlide = address - imageVMAddrSlide;</span><br><span class="line">    <span class="comment">// 拿到link_segment段的开始地址</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uintptr_t</span> segmentBase = bs_segmentBaseOfImageIndex(idx) + imageVMAddrSlide;</span><br><span class="line">    <span class="keyword">if</span>(segmentBase == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取镜像的路径名</span></span><br><span class="line">    info-&gt;dli_fname = _dyld_get_image_name(idx);</span><br><span class="line">    <span class="comment">// 镜像的header地址</span></span><br><span class="line">    info-&gt;dli_fbase = (<span class="keyword">void</span>*)header;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Find symbol tables and get whichever symbol is closest to the address.</span></span><br><span class="line">    <span class="keyword">const</span> BS_NLIST* bestMatch = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bestDistance = ULONG_MAX;</span><br><span class="line">    <span class="keyword">uintptr_t</span> cmdPtr = bs_firstCmdAfterHeader(header);</span><br><span class="line">    <span class="keyword">if</span>(cmdPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">uint32_t</span> iCmd = <span class="number">0</span>; iCmd &lt; header-&gt;ncmds; iCmd++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">loadCmd</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)<span class="title">cmdPtr</span>;</span></span><br><span class="line">        <span class="comment">// 找到symtab cmd段</span></span><br><span class="line">        <span class="keyword">if</span>(loadCmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtabCmd</span> = (<span class="title">struct</span> <span class="title">symtab_command</span>*)<span class="title">cmdPtr</span>;</span></span><br><span class="line">            <span class="comment">// 拿到symbol和string2张表，symboltable本质是一个nlist数组</span></span><br><span class="line">            <span class="keyword">const</span> BS_NLIST* symbolTable = (BS_NLIST*)(segmentBase + symtabCmd-&gt;symoff);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uintptr_t</span> stringTable = segmentBase + symtabCmd-&gt;stroff;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">uint32_t</span> iSym = <span class="number">0</span>; iSym &lt; symtabCmd-&gt;nsyms; iSym++) &#123;</span><br><span class="line">                <span class="comment">// 函数的入口地址</span></span><br><span class="line">                <span class="keyword">if</span>(symbolTable[iSym].n_value != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 符号在内存中的地址</span></span><br><span class="line">                    <span class="keyword">uintptr_t</span> symbolBase = symbolTable[iSym].n_value;</span><br><span class="line">                    <span class="comment">// 用返回值地址-符号基址</span></span><br><span class="line">                    <span class="keyword">uintptr_t</span> currentDistance = addressWithSlide - symbolBase;</span><br><span class="line">                    <span class="comment">// 找到符号表中地址距离返回地址最近的一条</span></span><br><span class="line">                    <span class="keyword">if</span>((addressWithSlide &gt;= symbolBase) &amp;&amp;</span><br><span class="line">                       (currentDistance &lt;= bestDistance)) &#123;</span><br><span class="line">                        bestMatch = symbolTable + iSym;</span><br><span class="line">                        bestDistance = currentDistance;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bestMatch != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// get name from stringTabel With dysm offset</span></span><br><span class="line">                info-&gt;dli_saddr = (<span class="keyword">void</span>*)(bestMatch-&gt;n_value + imageVMAddrSlide);</span><br><span class="line">                info-&gt;dli_sname = (<span class="keyword">char</span>*)((<span class="keyword">intptr_t</span>)stringTable + (<span class="keyword">intptr_t</span>)bestMatch-&gt;n_un.n_strx);</span><br><span class="line">                <span class="keyword">if</span>(*info-&gt;dli_sname == <span class="string">'_'</span>) &#123;</span><br><span class="line">                    info-&gt;dli_sname++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// This happens if all symbols have been stripped.</span></span><br><span class="line">                <span class="keyword">if</span>(info-&gt;dli_saddr == info-&gt;dli_fbase &amp;&amp; bestMatch-&gt;n_type == <span class="number">3</span>) &#123;</span><br><span class="line">                    info-&gt;dli_sname = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cmdPtr += loadCmd-&gt;cmdsize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>在模拟器上实验，最后的结果来说是完全符合预期的，除了有部分系统符号不能打出来。在真机上是什么表现呢？很遗憾，在真机上，很多私有API的符号都被去掉了，只能显示<code>&lt;redacted&gt;</code>，但是部分公开的API和自己的符号均能被打印。所以还是能帮助我们对问题的分析。其实符号化这部分过程其实就是对macho的一个处理，和我们fishhook中很相似。具体可以参考<a href="/源码解读/fishhook原理">fishhook原理/</a></p>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>类的本质</title>
    <url>/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上一章中，我们大概说了下内存分配相关的知识,我们从中知道了对象中保存了一个结构体指针isa，这个结构体是什么呢，对象又是怎么调用方法的呢，所以基于isa我们做进一步的了解</p>
<h4 id="对象的分类"><a href="#对象的分类" class="headerlink" title="对象的分类"></a>对象的分类</h4><p>Objective-C中的对象，简称OC对象，主要可以分为3种</p>
<ul>
<li><p>instance对象（实例对象）</p>
<p> instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *obj1 &#x3D; [[NSObject alloc] init];</span><br><span class="line">NSObject *obj2 &#x3D; [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>

<p>object1、object2是NSObject的instance对象(实例对象),分别占据着两块不同的内存</p>
<p>instance对象在内存中存储的信息包括isa指针、其他成员变量</p>
</li>
<li><p>class对象（类对象）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *obj1 &#x3D; [[NSObject alloc] init];</span><br><span class="line">NSObject *obj2 &#x3D; [[NSObject alloc] init];</span><br><span class="line">Class nsobjectClass &#x3D; obj1.class;</span><br><span class="line">Class nsobjectClass2 &#x3D; object_getClass(obj1)</span><br></pre></td></tr></table></figure>

<p>nsobjectClass ~ nsobjectClass2都是NSObject的class对象（类对象）,它们是同一个对象。每个类在内存中有且只有一个class对象</p>
<p>class对象在内存中存储的信息主要包括</p>
<p>isa指针、superclass指针、类的属性信息（@property）、类的对象方法信息（instance method）、类的协议信息（protocol）、类的成员变量信息（ivar）等等</p>
</li>
<li><p>meta-class对象（元类对象） </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class nsobjctMetaClass &#x3D; object_getClass(nsobjectClass);</span><br></pre></td></tr></table></figure>

<p>objectMetaClass是NSObject的meta-class对象（元类对象）</p>
<p>每个类在内存中有且只有一个meta-class对象</p>
<p>meta-class对象和class对象的内存结构是一样的(都是struct objc_class类型)，但是用途不一样</p>
</li>
</ul>
<h4 id="isa指针"><a href="#isa指针" class="headerlink" title="isa指针"></a>isa指针</h4><p>我们发现无论是实例对象，类对象，元类对象都有一个共同的属性isa。总所周知，我们实例对象中只有isa和成员变量，对象方法又保存在类对象中。那当我们用[objc instanceFunctionName]的时候是怎么处理的呢，其实就是通过isa找到类对象去做的调用。</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A81.png" alt="image-类的本质"></p>
<ul>
<li>当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用</li>
<li>当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用</li>
</ul>
<p>我们把思想抽象一点，从而把类对象当成元类对象的对象来看是一点问题都没有的。</p>
<p>我们可以把isa指针理解成对应类的地址，但是这并不准确，通过源码得知其实是做了一个位运算的</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A82.png" alt="image-类的本质"></p>
<h4 id="superclass指针"><a href="#superclass指针" class="headerlink" title="superclass指针"></a>superclass指针</h4><p>我们在上面有提到过类对象和元类对象中都有superclass指针，那么他是来干什么的呢。由于objc是面向对象的，对象对象的三大特性之一，继承。当一个类继承自父类时，要调用一个父类的对象方法，通过isa找到类对象，当类对象中没有这个方法时，就会通过superclass找到父类对象，从而一层层的找函数实现</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A83.png" alt="image-类的本质"></p>
<p>当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，然后通过superclass找到Person的class，最后找到对象方法的实现进行调用</p>
<p>同理元类对象也有一个类似的链条，相对应的就是类方法的实现寻找，就不做图解了</p>
<h4 id="调用链的总结"><a href="#调用链的总结" class="headerlink" title="调用链的总结"></a>调用链的总结</h4><p>这幅图应该到处都有看到</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A84.png" alt="image-类的本质"></p>
<ul>
<li>instance的isa指向class</li>
<li>class的isa指向meta-class</li>
<li>meta-class的isa指向基类的meta-class</li>
<li>class的superclass指向父类的class</li>
<li>如果没有父类，superclass指针为nil</li>
<li>meta-class的superclass指向父类的meta-class</li>
<li>基类的meta-class的superclass指向基类的class</li>
<li>instance调用对象方法的轨迹：isa找到class，方法不存在，就通过superclass找父类</li>
<li>class调用类方法的轨迹： isa找meta-class，方法不存在，就通过superclass找父类</li>
</ul>
<h4 id="Struct-objc-class"><a href="#Struct-objc-class" class="headerlink" title="Struct objc_class"></a>Struct objc_class</h4><p>总所周知，实例对象中的isa就是只想一个objc_class的结构体的指针,而类对象和实例对象也是一个objc_class的结构体。所以我们来看看源码</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A85.png" alt="image-类的本质"></p>
<p>由于类对象和元类对象都是这个结构，所以他们是一模一样的，只不过各自部分都有一些变量为空，类如元类对象中的ivars。我们也可以通过这幅图来理解</p>
<p><img src="/%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A86.png" alt="image-类的本质"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过这些，我们知道了对象和类对象还有元类对象的联系、结构、共同处还有不同处。也知道了isa指针的作用以及方法调用链。这会更有利于我们开发中理解一些问题，也知道了为什么iOS可以说万物皆对象，而且不是空口一说</p>
]]></content>
      <categories>
        <category>原理分析</category>
      </categories>
  </entry>
  <entry>
    <title>编译速度优化实践</title>
    <url>/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>项目跑了4年了，开发人员之前又多，业务又重。最近又遭到测试的投诉，说打包一次50min，觉得实在有点夸张，所以做一下编译的加速。特别是针对jenkins</p>
<h3 id="时间测量"><a href="#时间测量" class="headerlink" title="时间测量"></a>时间测量</h3><ul>
<li><p>​    Xcode保留了每次编译的日志，可以在Report Navigator中很快地找到</p>
<p>   <img src="/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/reportNavigator.png" alt="reportNavigator"></p>
</li>
<li><p>​    在 Xcode 的 activity viewer 中显示编译时间, 开启这个选项需要在命令行中执行以下命令：</p>
<blockquote>
<p>  defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES</p>
</blockquote>
</li>
</ul>
<p>编译成功后，编译时间将显示在 Succeeded 后面，如下图所示。<br>      <img src="/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/success.png" alt="success"><br>​      </p>
<h3 id="耗时分析"><a href="#耗时分析" class="headerlink" title="耗时分析"></a>耗时分析</h3><p>通过 <code>Xcode</code> 的 <code>Build With Timing Summary</code> 可以看到在编译过程中各个阶段的耗时, <code>Product &gt; Perform Action &gt; Build with Timing Summary</code> 或者 <code>xcodebuild -buildWithTimingSummary</code>。</p>
<p><img src="/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/buildTimingSummary.png" alt="buildTimingSummary"></p>
<p>在 <code>Report Navigator</code> 中可以看到下面的时间统计</p>
<p><img src="/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/reportNavigatorDetail.png" alt="reportNavigatorDetail"></p>
<p>可以看到 <code>CompileSoryboard</code>  <code>CompileC</code>、<code>CompileXIB</code> 花费了大量时间。<br><code>通过查看编译日志发现，PhaseScriptExecution</code> 阶段有重复的和可以精简的 <code>phase</code>。</p>
<p>由于项目很老，领导需要得到一个快速的结果，而且也要保证业务的稳定性，所以暂时不对xib和sb做处理，只是要求以后尽量少用。所以在下面几个方面来优化处理</p>
<blockquote>
<ol>
<li>修改项目的build settings</li>
<li>精简build phases</li>
<li>调整源码</li>
</ol>
</blockquote>
<h3 id="修改build-settings"><a href="#修改build-settings" class="headerlink" title="修改build settings"></a>修改build settings</h3><h5 id="Architectures"><a href="#Architectures" class="headerlink" title="Architectures"></a>Architectures</h5><p>该选项代表的编译生成的包对应的架构，默认值是$ARCHS_STANDARD，在Xcode11的表现下就是armv7 arm64。但是在给测试jenkins打包时我们并不需要总是打一个fat binary,毕竟armv7的机器还是少数，可以提供一个开关给测试。默认打arm64的单架构包。在xcodebuild的指令对应的值就是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ "$Iphone5sFollowingModels"x == "true"x ];</span><br><span class="line">then</span><br><span class="line">arch='armv7 arm64'</span><br><span class="line">else</span><br><span class="line">arch='arm64'</span><br><span class="line">fi</span><br><span class="line">xcodebuild archive xxxxx ARCHS=$arch</span><br></pre></td></tr></table></figure>

<h5 id="Optimization-Level-SWIFT-OPTIMIZATION-LEVEL"><a href="#Optimization-Level-SWIFT-OPTIMIZATION-LEVEL" class="headerlink" title="Optimization Level (SWIFT_OPTIMIZATION_LEVEL)"></a>Optimization Level (SWIFT_OPTIMIZATION_LEVEL)</h5><p>优化级别设置定义了优化构建的方式。由于优化过程涉及额外的工作，因此代码优化会导致构建时间变慢。release上默认是<strong>Fastest, Smallest[-Os]</strong>，但是在发往appstore的包，面向受众是用户，所以无可厚非。在jenkins中受众是我们的同事，所以无需做这些优化让编译器的cost增加。选用<strong>None</strong>就好，在xcodebuild的指令对应的就是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GCC_OPTIMIZATION_LEVEL=0</span><br><span class="line">GCC_OPTIMIZATION_LEVEL=s</span><br></pre></td></tr></table></figure>

<h5 id="Debug-Information-Format-DEBUG-INFORMATION-FORMAT"><a href="#Debug-Information-Format-DEBUG-INFORMATION-FORMAT" class="headerlink" title="Debug Information Format (DEBUG_INFORMATION_FORMAT)"></a>Debug Information Format (DEBUG_INFORMATION_FORMAT)</h5><p>包含用于符号化和解释崩溃报告的调试信息。Release 配置下应该始终创建此文件，Debug 配置下无需生成此文件，对应的指令是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">DEBUG_INFORMATION_FORMAT=dwarf-with-dsym</span><br><span class="line">DEBUG_INFORMATION_FORMAT=dwarf</span><br></pre></td></tr></table></figure>

<p>其实做完这几个编译速度就很明显了，我们项目中有接近50%的提升</p>
<h3 id="调整源码"><a href="#调整源码" class="headerlink" title="调整源码"></a>调整源码</h3><h5 id="pod二进制化"><a href="#pod二进制化" class="headerlink" title="pod二进制化"></a>pod二进制化</h5><p>很早之前就打算做这个件事，因为这个优化是对我们开发的编译速度也有提升的，也是对我们项目组件化的进一步提升</p>
<p>我们用的方案是二进制双私有源，采用的方案是用的<a href="https://github.com/MeetYouDevs/cocoapods-imy-bin" target="_blank" rel="noopener">imy-bin</a>,用起来挺方便的，不过吐槽一下。作者的这个项目真的不像开源的样子，提的issue全是直接关闭，给不了解决方案，走了很多坑最后还是跑起来了。</p>
<p>到最后把项目中现有的pod公有库私有库全部二进制化了，直接效果是编译的task从7000+变成了6000+。编译速度提高了百分之9左右，算达到想象中的效果，并且最重要的是，未来可期</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结合上面这些做法之后，我们的在jenkins上的打包速度提高了大概60%，而且我们之前用的打包机器也比较差，顺便也用了启用了另外一台打包机器，最好的加速果然是物理加速，从最开始最慢的打包需要2400s，到现在的500多s.也得到了测试的认可，并且接下来随着二进制化的增加，这个速度会越来越夸张！</p>
]]></content>
      <categories>
        <category>项目优化</category>
      </categories>
  </entry>
  <entry>
    <title>逆向笔记一</title>
    <url>/%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>接触了一段时间逆向，做了2个项目，但是接下来可能要有一段时间不会接触这方面的工作了。以防忘记，做一个简短的笔记来记录一下大概的流程。毕竟好记性不如烂笔头</p>
<h3 id="工欲善其事必先利其器"><a href="#工欲善其事必先利其器" class="headerlink" title="工欲善其事必先利其器"></a>工欲善其事必先利其器</h3><p>主要分为硬件和软件(包括环境配置)部分</p>
<h6 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h6><ul>
<li><p>越狱手机一只，建议越狱系统新一些的，毕竟有些应用的最新版本已经不支持老的系统版本了，逆向的代码相当于也是老版本的</p>
</li>
<li><p>mac一部，黑苹果也可，所有的逆向的代码还是要依赖于XCode</p>
</li>
<li><p>windows电脑一台(可选)，如果mac的配置足够优秀，或者时间不是很赶可以不用。只是单纯拿来做反汇编用，腾出自己的mac做其他的分析或者编码工作</p>
<hr>
</li>
</ul>
<h6 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h6><ul>
<li>反汇编软件,IDA,Hooper、MachOView、电脑端的reveal</li>
<li>手机上的一些动态调试插件,reveal、cycript、debugserver的环境、Flex、以及需要逆向的app</li>
<li>电脑上对应的环境，frida、class-dump、cycript、monkeyDev(大幅度提升效率)、IDA的一些插件，例如restore_symbol…</li>
<li>编译器，Xcode、sublime Text(方便我们看头文件)</li>
</ul>
<h3 id="个人操作步骤"><a href="#个人操作步骤" class="headerlink" title="个人操作步骤"></a>个人操作步骤</h3><p>只代表个人观点，自己水平也只是勉强入门，所以谨代表个人的一些习惯</p>
<ol>
<li>自己会先把玩一些对应的应用，操作一下的对应的功能。因为自己是做正向开发的。玩的时候代入一些自己的思路</li>
<li>砸壳,逆向必不可少。个人倾向用frida-iOS-dump砸，查看加密信息看砸壳是否成功</li>
<li>Class-dump导入头文件，并且用sublime打开，方便后续查找文件和代码</li>
<li>反汇编，个人习惯是用IDA和hooper一样弄一份，因为自己有2台电脑不耽误。</li>
<li>在反汇编的过程中会做一些简单的动态调试，flex配合cycript用，flex做一些简单的动态调试真的很好用，简单，不需要写代码。一个手机即可，很方便在地铁做这些事情</li>
<li>符号表恢复，利用restore_symbol工具，顺便利用IDA的脚本把block的符号表也恢复掉。方便断点和静态分析</li>
<li>替换完处理好的包之后直接用monkeyDev来跑到真机上来做后续的调试</li>
<li>静态调试和动态分析配合起来做分析和调试。需要往上查看调用栈就打断点、动态调试，需要往下看调用栈就只能静态分析。</li>
<li>静态分析不建议硬磕汇编，可以利用好f5的功能，但是不能过度依赖</li>
<li>调试过程中利用logs写日志、断点、以及配合头文件来做调试和验证</li>
<li>写完之后做验证以及写好Tweak</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这只是一篇简单的日记，来梳理下自己的流程，在做完了2个项目之后，对有些正向开发的底层有了更一步的了解。虽然在读汇编的过程中头皮发麻，不过最终完成的时候真的非常畅快。后续会继续在这方便做进一步的学习</p>
<ul>
<li><input disabled type="checkbox"> </li>
</ul>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>首页重构</title>
    <url>/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E9%A6%96%E9%A1%B5%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>上半年我主要的任务也是做一个首页的重构，伴随着2季度的结束，也终于有时间来对这个方面来做一个总结</p>
<h4 id="现存的问题"><a href="#现存的问题" class="headerlink" title="现存的问题"></a>现存的问题</h4><ul>
<li><strong><em>字典软编码</em></strong>  大量后台数据回来不做本地解析，直接用字典进行操作。 这样做首先编译器没有任何提示，拥有敲错的隐患，而且开发效率不高。 另外在字典写以及传值中经常会变成可变字典。导致多个环境中本来应该共享的数据其实并不是同一份。而解析成本地的对象直接对对象进行操作可以很好的弥补这一点</li>
<li><strong><em>没有任何代码架构</em></strong>   由于首页已经迭代了5年，每个开发的水平又不一样。所以各种所谓的MVC和MVVM混用，导致难以迭代</li>
<li><strong><em>没有任何的业务分层</em></strong>   由于电商业务迭代的快速性。之前所有的开发都是在屎山上进行迭代，后果就是让屎山变得更屎，以至于现在出了问题及其难查。所有的业务都是为了快速交付。业务代码全部杂糅在一起，光首页控制器中就有2w+行代码</li>
<li><strong><em>性能低下</em></strong>   早期整个视图用的是tableview，导致之后做一些瀑布流的操作只能用各种视图嵌套的方式来完成，导致性能低下，冗余代码过多</li>
<li><strong><em>太多数据处理在客户端</em></strong>  由于之前客户端的同事在和其他部门pk的时候过于不够强势，所以大量的数据处理都在客户端。让客户端拿到的数据基本不可直接使用，要多个接口进行拼接，筛选，甚至排序才能使用，进一步导致了</li>
<li><strong><em>完全无法多人开发</em></strong>。由于上述这些特性，导致完全只能由熟悉首页的同事开发，而我们需求主要迭代都是关于首页。直接导致了“1核开发，多核围观”</li>
</ul>
<h4 id="想达到的效果"><a href="#想达到的效果" class="headerlink" title="想达到的效果"></a>想达到的效果</h4><ul>
<li><strong><em>视图的升级</em></strong>  作为tableview的升级版collectionview，可以完美完成tab的诉求，并且可以做很多tab做不到的事情。另外首页中还有大量的其他的小视图没有做好层级分类。例如多个子视图都应该做为一个父视图交付给首页，而被写成了每个子视图都提供了对应的interface给外界进行了访问。应该对这种类型的视图进行收束，让首页的构成变成简单的一个collectionview+ 若干个大视图的方式。大视图管理自己的子视图，提供统一的接口给首页访问</li>
<li><strong><em>数据层的处理</em></strong>  客户端需要的数据必须更加纯粹，相对于代码的架构来说。部门的架构同样重要，任务分工是很有必要的。将一些数据处理的逻辑放在后台可以直接让客户端、h5端3端的工作量大大减小。整体的代码也清晰明了</li>
<li><strong><em>复杂且多样的cell的处理</em></strong>  对于collectionview来说，装载的肯定是各种各样的cell，但是我们以往的写法都是判断数据的类型，然后拿到不同的reuseidentifier,然后进行生成cell。或者拿到不同的itemsize，这样重复的代码在大量的代理和数据源的方法中再来n次。其实既然数据是从后台来的，每个后台回来的model肯定有数据来标识不同类型的展示方式，然后每个cell都需要itemsize以及重用标识符等等共同字段。其实可以利用面向对象的方式进行一层封装。控制器的数据源数组种装载的就是这些一层层封装的数据。对于需要用到的时候从数组中可以利用逆变的思想。因为对于数据源和代理来说，父类的这些数据使用。然后对于所有的cell抽一个公共的父类，提供一个接受转换过的数据来丰富自己内容的方法。在经过上面数据重用来的cell我们还是可以通过逆变来看待成统一的父类的cell，然后用上面说过的填充的方法去丰富他自身。这个时候就会利用到多态的真实类型，在每个实际类型的cell中来进行这个丰富自身的实现</li>
<li><strong><em>面向模型的开发</em></strong>  所有的页面的各个模块是否展示，展示成什么样都由对应的数据模型模块来决定。view只是这个数据的一种展现形式，结合上面<u><em>复杂且多样的cell的处理</em></u>让开发业务起来更加简单，毕竟客户端大部分的时间都是在写ui。可以更好的把ui剥离开，从而在逻辑上以及交互上更加纯粹以及简单，从而bug也会更少</li>
<li><strong><em>结构的分层</em></strong>  尽可能的进行结构分层，该是vc就是vc，该是view就是view,数据层就是数据层，网络层就是网络层，以及埋点，路由等等，并且让每个结构尽可能纯粹只做属于自身的事情，这是mvc很基础的理念了</li>
<li><strong><em>统一的代码风格</em></strong>  确定统一的风格，利用模版生成一些胶水代码，很方便后续的维护以及多人参与</li>
<li><strong><em>快捷简便的多人开发</em></strong>  通过上诉这些处理加上一些文档以及分享，来统一意识。多人可以用同样的思想来思考首页的迭代，更加方便多人开发。让每个人知道如果首页出了问题应该去哪个模块的哪个层的哪个文件的哪个函数去查。同样增加业务删除业务也是</li>
</ul>
<h4 id="实现的主题技术框架"><a href="#实现的主题技术框架" class="headerlink" title="实现的主题技术框架"></a>实现的主题技术框架</h4><p> 不怎么想去讨论mvc以及mvvm的孰优孰劣。本来不同的业务就该用不同的架构，为了架构而去架构是一件很没有必要的事情，所有的技术都是为业务负责。对我个人而言就是简单的稳定的业务我会用mvc。而繁重的快速迭代的业务用mvvm。很显然首页是典型的后者</p>
<p>另外我会考虑使用 <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">FRP</a>中OC的框架<a href="https://github.com/ReactiveCocoa/ReactiveObjC" target="_blank" rel="noopener">RAC</a>,<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">FRP</a>是一个学习难度很陡峭的思想，但是非常好用。尽管他有一些缺陷，但是在我需要面向模型开发这种思想的时候非常好用，让我不用任何数据变动都进行整个页面的reload，并且可以更加放大mvvm的功效，在我构思好整个页面的”input” + “output”的时候mvvm+FRP能起到更好的效果，这点会在下面进行更好的体现</p>
<p>我还会考虑去使用<a href="https://github.com/Instagram/IGListKit" target="_blank" rel="noopener">IGListKit</a>, 作为一个instagram出品的一个关于collectionview的框架，他有太多的优点。例如文档中所说</p>
<blockquote>
<ol>
<li>无须直接调用 <code>performBatchUpdates(_:, completion:)</code> 或 <code>reloadData()</code></li>
<li>更好的可复用 cell 和组件体系结构</li>
<li>创建具有多个数据类型的列表</li>
<li>解耦的 Diff 算法</li>
<li>完全的单元测试</li>
<li>可自定义数据模型的 Diff 行为</li>
<li>简化并维持<code>UICollectionView</code>的核心特性</li>
<li>可扩展的 API 设计</li>
<li>Objective-C 编写,同时完全支持 Swift</li>
</ol>
</blockquote>
<p>但是对我而言，最重要的是1 2 6 7这几点。在以往开发中我们collectionview的单行增删改的过程中如果对数据以及视图没有做好对应很容易产生崩溃。而IGListKit的diff可以避免这个问题。并且IGList可以更加发挥我面向数据开发以及多个数据类型的cell的需求。而且在开发中虽然我们尽量保持cell作为一个view的展示属性的纯粹。但是在业务开发中cell的一些页面的交互和跳转是不可避免的，我们当然可以通过回调或者代码一层层回调出来。然后IGList的这种sectionController可以完美解决这种问题。这种view和控制器的剥离方式实在是太赞了</p>
<h4 id="大概的蓝图构思"><a href="#大概的蓝图构思" class="headerlink" title="大概的蓝图构思"></a>大概的蓝图构思</h4><p><img src="/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E9%A6%96%E9%A1%B5%E9%87%8D%E6%9E%84/%E9%A6%96%E9%A1%B5%E9%87%8D%E6%9E%841.png" alt="首页重构"></p>
<p>我大概理想中的首页重构是这样的，从控制器说起</p>
<h6 id="VC中的几大模块"><a href="#VC中的几大模块" class="headerlink" title="VC中的几大模块:"></a>VC中的几大模块:</h6><ul>
<li><strong><em>View :</em></strong> 呈现的内容，像我们首页中大的主体是一个collectionview，以及几个其他整合封装好的其他的view，例如悬浮窗啊等等..</li>
<li><strong><em>ViewModel :</em></strong>  mvvm中核心的vm层，搭配RAC把ViewModel做成一个管道，有注入口和出水口，这个想法比较抽象，首先说出水口就是图中对应解析好一个个cellModel组成的groupModel给控制器直接解析给collectionview使用，对应的就是之前IGListKit的一个sectionController然后。而Input就是指的是一切会改变页面显示样式的操作。例如页面的加载，页面的下拉刷新，上啦加载更多，甚至用户点击了一个按钮页面上要做对应的增删改都可以理解为InPut。然后viewModel就是把这些Input 进行map，变成本地的或者从新进行网络请求的数据，然后生成对应的新的cellmodel。然后发送output信号，从而订阅了output信号的视图进行更新。所以 把viewmodel抽象成管道的理解就可以非常容易了</li>
<li><strong><em>Tool层:</em></strong>  包含了一些工具类，例如我们首页有截屏分享的功能,还有一些功能都可以抽成工具类。另外还有很重要的用户响应层，这里面处理了页面上所有用户的点击的回调分发，例如跳转到商详页面。其中响应层又包含了埋点层和路由层，因为对大多数客户端的点击来说，一个点击基本都是跳转到一个页面。而我们业务之前在做组件化的时候就已经把所有的跳转路由化了。所以路由层承接的是跳转的功能，而埋点层则承接的是埋点</li>
<li><strong><em>NetWork层：</em></strong> 属于viewmodel的附属，包含了当前业务模块的所有网路请求，提供了一系列的请求方法来请求不同模块的数据。起的作用是整合所有网络层，请求参数以及把json解析成model给ViewModel层的作用</li>
</ul>
<h4 id="大概的实施步骤"><a href="#大概的实施步骤" class="headerlink" title="大概的实施步骤"></a>大概的实施步骤</h4><p>方案定下来了之后就是大概的实施，但是由于重构首页这么大的模块肯定有很大的工作量和风险。所以在争取资源和规避风险要做到一些努力。在规避风险上我们是按照具体的顺序来重构，让每个版本上线的模块尽可能的小。把风险分散化</p>
<ul>
<li><strong><em>开会说方案，以及拉后台和测试争取资源。例如让后台整合接口以及处理数据，承接以前客户端处理数据的功能，同时解放安卓和h5。争取测试资源，分批测试重构的内容，首页重中之中，确保万无一失去。</em></strong></li>
<li><strong><em>提前准备好ab方案，每次的重构内容都有开关，如果真的线上有问题进行开关关闭，稳定上线2个版本撤销对应的开关</em></strong></li>
<li><strong><em>按照好顺序来分期重构业务，分散风险以及和测试和开发预留时间。例如我们1期先上一些边边角角的视图，对整体的代码模块变动并不大。二期把网络层整合出来，也不用更改一些控制器的代码，只是把代码进行整合和优化。三期就把之前的cell变动成我们上面所说的模式的cell…..等等按照节奏一步步的来处理，让测试有节奏的把握风险</em></strong></li>
<li><strong><em>删除无用的代码，这点也很重要，因为删除了无用代码可以让后来的人在查找业务方便很多，也可以提高少量的编译速度以及降低包体积</em></strong></li>
<li><strong><em>整体完成上线之后在组内进行多次分享和宣讲，推广到其他业务。让所有人都懂这个模式并且按照这个模式开发</em></strong></li>
</ul>
<h4 id="一些样板代码"><a href="#一些样板代码" class="headerlink" title="一些样板代码"></a>一些样板代码</h4><p>在上面我们有说我们把所有的cell提供统一的接口来充实自己的内容，同样我们给所有的模型也提供一些cell要用的通用属性。其实很简单，大概的代码就长成这个样子</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BaseCellModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 原始数据的实例对象 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> entity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*! identifier */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *cellIdentifier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> *  @brief 子类复写create。从而延迟创建cellModel的内容。也可以重写初始化方法，创建cellModel的内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEntity:(<span class="keyword">id</span>)entity <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 子类重写返回对应的identifier</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)configCellIdentifier;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)create <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BaseColViewCellModel</span> : <span class="title">BaseCellModel</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! itemeSize */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> itemSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 子类重写返回对应的itemSize</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">CGSize</span> )configItemSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>因为相当于的BaseColViewCellModel还有一个对应的tableviewCell的版本，所有通用的都封装在BaseCellModel里，接口中提供一个接受id类型的数据，就是服务器的原始数据。然后子类调用对应的create方法并且在内部实现成视图需要的数据，例如一大串的富文本。保证cell可以直接用cellmodel的成员变量。 而cellIdentifier就是给数据源来初始化对应的cell使用的。内部统一的实现就是,结果就是自己的类型去除掉model几个字，就是cell的类名。当然如果有特殊的情况可以子类重写。同样configItemSize就是子类来实现自己大小的函数，执行一次之后会赋值给itemsize，起到缓存和降低cpu资源消耗的作用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)configCellIdentifier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *str = <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class);</span><br><span class="line">    <span class="keyword">return</span>   [str substringToIndex:str.length - <span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而cell就长成这个样子</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BaseCollectionViewCell</span>&lt;<span class="title">T</span>: <span class="title">BaseColViewCellModel</span> *&gt; : <span class="title">UICollectionViewCell</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据对象</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) T entity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 根据数据配置视图</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @param entity 数据对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)configureWithEntity:(T)entity <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  自动返回cell的identifierId格式为【xib名称】</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 格式为【xib名称/ 类名】(如：XXXViewCell)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">NSString</span>*)getCollectionViewCellIdentifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">void</span>)configureWithEntity:(<span class="keyword">id</span>)entity</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.entity = entity;</span><br><span class="line">    <span class="comment">// bind data -&gt; view, by subclass...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *)getCollectionViewCellIdentifier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>configureWithEntity就是把cellmodel展示在自己内部视图的实现，getCollectionViewCellIdentifier就直接返回的是自己的类名，恰好和对应cellmodel的对象方法成了一一对应，其实这个类方法是用给注册cell的。避免软编码。另外我会在这一层再进行一层业务层的封装。类似这样</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^HomeInteractionClosure)(<span class="keyword">id</span> _Nullable obj,HomeInteractionType type, <span class="keyword">id</span> _Nullable additionObj);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HomeBaseCollectionViewCell</span> : <span class="title">BaseCollectionViewCell</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*! 点击回调 */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) HomeInteractionClosure interactionClosure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>方便统一处理回调给vc的interactionTool，其实做完这些胶水代码之后首页对cell的处理大概就是这个样式的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">HomeBaseCellModel *model = <span class="keyword">self</span>.sectionModels[indexPath.section].colCellModels[indexPath.row];</span><br><span class="line"></span><br><span class="line">BaseCollectionCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:model.cellIdentifier forIndexPath:indexPath];</span><br><span class="line">[cell configureWithEntity:model];</span><br><span class="line"></span><br><span class="line">@weakify(<span class="keyword">self</span>)</span><br><span class="line">cell.interactionClosure = ^(<span class="keyword">id</span>  _Nullable obj, YJPopInteractionType type, <span class="keyword">id</span>  _Nullable additionObj) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在viewmodel层内部请求到数据之后，viewModel会根据不同类型的服务器数据生成对应的cellModel然后统一抛给控制器，然后通过统一的成员变量拿到不同的identifier来生成不同的cell。然后调用统一的填充接口让具体的真实类型负责自己内部的处理</p>
<h4 id="一些成果和缺点"><a href="#一些成果和缺点" class="headerlink" title="一些成果和缺点"></a>一些成果和缺点</h4><p>在耗时接近半年之后，项目完美交付。取得了很多成果但是也有一些弊端，先拿弊端来说</p>
<h6 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h6><ul>
<li><p><strong><em>学习成本有点陡峭</em></strong>  因为这套东西利用了frp的思想以及大量的面相对象的知识，面相对象倒还好，但是对于客户端开发来说以往的编码习惯都是，所有的view都通过数据填充，用户点了按钮外抛出去，更新数据，然后调用视图的对应的更新方法来更新视图。所有frp这套思维很颠覆以往的习惯。更不谈input和output这种高度抽象，把用户行为抽象成响应流的操作了。所以我们后期都是开展大量的分享来帮大家一起提高。因为这么做不仅简化了代码，也简化了思维，在一个业务在下之后想好了所有的出入口。可以极大的降低bug率。并且这种方式也更适合后续的SwiftUI这种声明式UI+FRP的开发方式。我觉得不仅是iOS，整个客户端甚至大前端的大概方向都是如此</p>
</li>
<li><p><strong><em>会需要写少量的胶水代码</em></strong>  模块的拆分不可避免的需要面对这个问题，像上面的那些都属于胶水代码，我们对这里处理方式是做成对应的模版，让开发直接使用模版来操作。例如下图我们只需要点击第一个按钮，然后输入对应的模块名，以及注释。我们就会生成对应的cell和cellModel2个类的.h.m文件。cell中的代码大概是这样的。这么做就可以避免写胶水代码的同时还统一了团队的代码风格，对应的工程师只需要按图索骥，在对应的函数里进行填鸭就行了</p>
</li>
</ul>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - <span class="meta-string">&lt;lifeCycle&gt;</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setupUI];</span><br><span class="line">        [<span class="keyword">self</span> makeConstraints];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupUI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do setup ui code, plz make sure all subviews are added to contentView, not cell</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)makeConstraints</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do constraints code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)configureWithEntity:(SubjectCardCellModel *)entity &#123;</span><br><span class="line">    [<span class="keyword">super</span> configureWithEntity:entity];</span><br><span class="line">    <span class="keyword">if</span> (![entity isKindOfClass:SubjectCardCellModel.class]) &#123; <span class="keyword">return</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - <span class="meta-string">&lt;userInterfaction&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>  ​    而cellModel中的大概是这样的</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)create &#123;</span><br><span class="line">    [<span class="keyword">super</span> create];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// safe check</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.entity isKindOfClass:&lt;#ClassType#&gt;.class]) &#123; <span class="keyword">return</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// model -&gt; cellModel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGSize</span>)configItemSize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGSizeZero</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E9%A6%96%E9%A1%B5%E9%87%8D%E6%9E%84/%E9%A6%96%E9%A1%B5%E9%87%8D%E6%9E%842.png" alt="首页重构"></p>
<p><img src="/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/%E9%A6%96%E9%A1%B5%E9%87%8D%E6%9E%84/%E9%A6%96%E9%A1%B5%E9%87%8D%E6%9E%843.png" alt="首页重构"></p>
<h6 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h6><ul>
<li><strong><em>极大降低了迭代难度</em></strong>  <strong><em>:</em></strong> 经过重构之后，各个模块结构清晰。例如需要在首页新增一个模块，就只需要用模版新建一个模块，再内部写对应的视图和转化数据。然后再viewModel中把后台新给的数据转化成对应的cellModel类型就好。 再说删除，如果需要删除某一个模块，只需要在viewModel中把对应模块的解析注释掉就行了。对于改动和查找代码也很简单，例如页面的尺寸或者展示有问题，就去cell中，如果展示出来的数据有问题，就看服务器数据以及自己cellModel中的 转换是否有问题，埋点则去埋点层。交互就去交互层，非常简单</li>
<li><strong><em>极大的方便了多人开发</em></strong> <strong><em>:</em></strong> 从上面就可以看到，由于统一了范式以及功能模块化之后，看代码非常简单，甚至可以把一个新业务的细粒度拆到令人发指。甚至可以一个人去专门写ui，一个人写解析</li>
<li><strong><em>大大降低了bug率:</em></strong> 通过这种方式后更加方便了单元测试，而且编程的思想也进行了对应的改变，一个业务下来了之后，大家都会想好这个业务的出入口。哪些用户的操作会引起业务的改变。除去机械化的ui代码以外，可以更加集中精力在逻辑代码上。像我们无论是同比还是环比，组内的bug率普遍下降了40%</li>
<li><strong><em>极大的提高了开发效率</em></strong>： 直接通过我们的效能平台，光我们iOS的交付效率比以往高了30%还多</li>
<li><strong><em>让开发更加轻松又更加会思考:</em></strong>  经过这次重构之后，普遍组内的人对业务会进行更加深度的思考，也会积极的去和外部部门pk，例如后台和测试。更加有利于团队的竞争和成长</li>
</ul>
]]></content>
      <categories>
        <category>工作总结</category>
      </categories>
  </entry>
</search>
